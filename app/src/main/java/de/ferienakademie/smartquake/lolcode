package de.ferienakademie.smartquake.view;

        import android.view.View;

        import java.util.ArrayList;
        import java.util.List;

        import de.ferienakademie.smartquake.model.Beam;
        import de.ferienakademie.smartquake.model.Node;
        import de.ferienakademie.smartquake.model.Structure;

/**
 * Created by yuriy on 22/09/16.
 */
public class DrawHelper {

    public static List<Node> snapNodes = new ArrayList<>();
    public static List<Beam> snapBeams = new ArrayList<>();
    public static double[] boundingBox = new double[4];

    public static void drawStructure(Structure structure, View view1) {
        snapShot(structure.getNodes(), structure.getBeams());
        boundingBox = structure.getBoundingBox();
        if (view1 instanceof CanvasView) {
            CanvasView view = (CanvasView)view1;
            view.isBeingDrawn = true;
        }
        if (view1 instanceof DrawCanvasView) {
            DrawCanvasView view = (DrawCanvasView)view1;
            view.isBeingDrawn = true;
        }
        view1.postInvalidate();
    }

    public static void clearCanvas(View view1) {
        snapBeams.clear();
        snapNodes.clear();
        if (view1 instanceof CanvasView) {
            CanvasView view = (CanvasView)view1;
            view.isBeingDrawn = true;
        }
        if (view1 instanceof DrawCanvasView) {
            DrawCanvasView view = (DrawCanvasView)view1;
            view.isBeingDrawn = true;
        }
        view1.postInvalidate();
    }

    private static void snapShot(List<Node> nodes, List<Beam> beams) {
        snapBeams.clear();
        snapNodes.clear();
        snapBeams.addAll(beams);
        snapNodes.addAll(nodes);
    }

}
package de.ferienakademie.smartquake.view;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.util.AttributeSet;
import android.view.View;

/**
 * Created by yuriy on 21/09/16.
 */
class GroundView extends View {

    public GroundView(Context context) {
        super(context);
    }

    public GroundView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public GroundView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    public GroundView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        Paint red = new Paint();
        red.setColor(Color.DKGRAY);
        red.setStyle(Paint.Style.FILL_AND_STROKE);
        red.setAntiAlias(true);

        canvas.drawPaint(red);
    }
}
package de.ferienakademie.smartquake.view;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Path;
import android.util.AttributeSet;
import android.view.View;

import de.ferienakademie.smartquake.model.Beam;
import de.ferienakademie.smartquake.model.Node;

/**
 * Created by yuriy on 24/09/16.
 */
public class DrawCanvasView extends View {
    public static final Paint PAINT = new Paint();

    public static final double NODE_RADIUS_PIXEL = 15;

    static {
        PAINT.setColor(Color.RED);
        PAINT.setStyle(Paint.Style.FILL_AND_STROKE);
        PAINT.setAntiAlias(true);
    }

    public boolean isBeingDrawn = false;

    public DrawCanvasView(Context context) {
        super(context);
    }

    public DrawCanvasView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public DrawCanvasView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    public DrawCanvasView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
    }


    @Override
    protected void onDraw(Canvas canvas) {
        isBeingDrawn = true;
        super.onDraw(canvas);

        for (Beam beam : DrawHelper.snapBeams) {
            drawBeam(beam, canvas, PAINT);
        }
        for (Node node : DrawHelper.snapNodes) {
            drawNode(node, canvas, PAINT);
        }
        isBeingDrawn = false;
    }

    public static void drawBeam(Beam beam, Canvas canvas, Paint paint) {
        Node startNode = beam.getStartNode();
        Node endNode = beam.getEndNode();
        paint.setStrokeWidth(10);
        canvas.drawLine((float) startNode.getInitialX(), (float) startNode.getInitialY(),
                (float) endNode.getInitialX(), (float) endNode.getInitialY(), paint);
    }

    public static void drawNode(Node node, Canvas canvas, Paint paint) {
        Paint nodePaint;
        if (node.isHinge()) nodePaint = CanvasView.HINGE_PAINT;
        else nodePaint = CanvasView.BEAM_PAINT;
        canvas.drawCircle((float) node.getInitialX(), (float) node.getInitialY(), (float) NODE_RADIUS_PIXEL, nodePaint);
    }
}
package de.ferienakademie.smartquake.view;

import android.accessibilityservice.GestureDescription;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.DashPathEffect;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.Shader;
import android.util.AttributeSet;
import android.view.View;

import java.util.Arrays;

import de.ferienakademie.smartquake.model.Beam;
import de.ferienakademie.smartquake.model.Node;

public class CanvasView extends View {
    // for future reference: 1 dpi = 100 / 2.54 pixels per meter
    // get dpi with context.getResources().getDisplayMetrics().xdpi

    public static final double SIDE_MARGIN_SCREEN_FRACTION = 0.125;
    public static final double TOP_MARGIN_SCREEN_FRACTION = 0.125;
    public static final double BEAM_UNIT_SCREEN_FRACTION = 0.1;
    public static final Paint BEAM_PAINT = new Paint();
    public static final Paint HINGE_PAINT = new Paint();
    public static final Paint RULER_PAINT = new Paint();

    static {
        BEAM_PAINT.setColor(Color.RED);
        BEAM_PAINT.setStyle(Paint.Style.FILL_AND_STROKE);
        BEAM_PAINT.setAntiAlias(true);

        RULER_PAINT.setColor(Color.BLACK);
        RULER_PAINT.setAntiAlias(true);

        HINGE_PAINT.setColor(Color.BLUE);
        HINGE_PAINT.setAntiAlias(true);
    }

    // TODO: improve?
    public boolean isBeingDrawn = false;
    private double[] screenCenteringOffsets = new double[2];
    private double[] negativeMinCorrections = new double[2];
    private double modelScaling, beamUnitSize;

    public CanvasView(Context context) {
        super(context);
    }

    public CanvasView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public CanvasView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    public CanvasView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
    }

    private float internalToScreen(double internal_value, Axis axis) {
        return (float) ((internal_value + negativeMinCorrections[axis.ordinal()]) * modelScaling + screenCenteringOffsets[axis.ordinal()]);
    }

    public void drawNode(Node node, Canvas canvas) {
        Paint nodePaint;
        if (node.isHinge()) nodePaint = HINGE_PAINT;
        else nodePaint = BEAM_PAINT;

        canvas.drawCircle(internalToScreen(node.getCurrentX(), Axis.X),
                internalToScreen(node.getCurrentY(), Axis.Y),
                (float) (node.getRadius() * beamUnitSize), nodePaint);
    }

    private static class InternalColorStop implements Comparable
    {
        int color;
        double pos;

        InternalColorStop(int color, double pos)
        {
            this.color = color;
            this.pos = pos;
        }


        @Override
        public int compareTo(Object o) {
            return Double.compare(pos, ((InternalColorStop)o).pos);
        }
    }

    private static final InternalColorStop[] colorStops =
            {
                    new InternalColorStop(Color.argb(255, 0, 0, 255), -250), //BLUE
                    new InternalColorStop(Color.argb(255, 0, 0, 0), 0), //BLACK
                    new InternalColorStop(Color.argb(255, 255, 0, 0), 250) //RED

            };

    private int lerp(int f, int s, double p)
    {
        //Standard linear interpolation.
        return Color.argb(
                (int)Math.round(Color.alpha(f) * (1 - p) + Color.alpha(s) * p),
                (int)Math.round(Color.red(f) * (1 - p) + Color.red(s) * p),
                (int)Math.round(Color.green(f) * (1 - p) + Color.green(s) * p),
                (int)Math.round(Color.blue(f) * (1 - p) + Color.blue(s) * p)
        );
    }

    private void beamDeformationColor(Beam beam, Paint paint)
    {
        double force = beam.calculateNormalForceOfBeam(); //Might still show some errors.

        //Please don't ask for a reason to take such a comparably const-high algo on a small list, I was just lazy.
        int idx = Arrays.binarySearch(colorStops, new InternalColorStop(0, force));

        //The case why this is needed is explained very well in the documentation.
        if (idx < 0) {
            idx = -(idx + 1);
        }
        //Handling
        if (idx <= 0)
        {
            paint.setColor(colorStops[0].color);
        }
        else if (idx >= colorStops.length)
        {
            paint.setColor(colorStops[colorStops.length - 1].color);
        }
        else
        {
            //We interpolate.
            InternalColorStop thisStep = colorStops[idx];
            InternalColorStop lastStep = colorStops[idx - 1];

            double factor = (force - lastStep.pos) / (thisStep.pos - lastStep.pos);

            int color = lerp(lastStep.color, thisStep.color, factor);

            paint.setColor(color);
        }
    }

    private void resetBeamColor(Paint paint)
    {
        paint.setColor(Color.RED);
    }

    private void drawBeam(Beam beam, Canvas canvas) {
        Node startNode = beam.getStartNode();
        Node endNode = beam.getEndNode();
        Path p = new Path();

        p.moveTo(internalToScreen(startNode.getCurrentXf(), Axis.X), internalToScreen(startNode.getCurrentYf(), Axis.Y));

        int numberOfSegments = 20;
        double singleSegmentLength = beam.getLength() / numberOfSegments;

        for (float x = 0; x < beam.getLength(); x += singleSegmentLength) {
            double px = (endNode.getInitialX() - startNode.getInitialX()) / beam.getLength() * x + startNode.getInitialX();
            double py = (endNode.getInitialY() - startNode.getInitialY()) / beam.getLength() * x + startNode.getInitialY();

            float[] intermediateDisplacement = beam.getGlobalDisplacementAt(x);
            intermediateDisplacement[0] = internalToScreen(intermediateDisplacement[0] + px, Axis.X);
            intermediateDisplacement[1] = internalToScreen(intermediateDisplacement[1] + py, Axis.Y);
            p.lineTo(intermediateDisplacement[0], intermediateDisplacement[1]);
        }

        p.lineTo(internalToScreen(endNode.getCurrentXf(), Axis.X), internalToScreen(endNode.getCurrentYf(), Axis.Y));

        BEAM_PAINT.setStrokeWidth((float) (beam.getThickness() * beamUnitSize));

        //Sorry for this code.
        beamDeformationColor(beam, BEAM_PAINT);
        canvas.drawPath(p, BEAM_PAINT);
        resetBeamColor(BEAM_PAINT);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        isBeingDrawn = true;
        super.onDraw(canvas);

        RULER_PAINT.setStrokeWidth(canvas.getWidth() / 144);
        RULER_PAINT.setTextSize(canvas.getHeight() / 38);

        double[] boundingBox = DrawHelper.boundingBox;
        double modelXSize = boundingBox[1] - boundingBox[0];
        double modelYSize = boundingBox[3] - boundingBox[2];
        // special case for single beam
        if (modelXSize == 0){
            modelXSize = 8;
        }
        if (modelYSize == 0) {
            modelYSize = 8;
        }

        double widthFitScaling = (1 - 2 * SIDE_MARGIN_SCREEN_FRACTION) * canvas.getWidth() / modelXSize;
        double heightFitScaling = (1 - TOP_MARGIN_SCREEN_FRACTION) * canvas.getHeight() / modelYSize;

        if (widthFitScaling < heightFitScaling) {
            modelScaling = widthFitScaling;
            drawRuler(modelXSize, canvas);
        } else {
            modelScaling = heightFitScaling;
            drawRuler(modelYSize, canvas);
        }

        screenCenteringOffsets[0] = 0.5 * (canvas.getWidth() - modelXSize * modelScaling);
        screenCenteringOffsets[1] = canvas.getHeight() - modelYSize * modelScaling;
        beamUnitSize = canvas.getWidth() * BEAM_UNIT_SCREEN_FRACTION;

        if (boundingBox[0] < 0) {
            negativeMinCorrections[0] = -boundingBox[0];
        } else {
            negativeMinCorrections[0] = 0;
        }

        if (boundingBox[2] < 0) {
            negativeMinCorrections[1] = -boundingBox[1];
        } else {
            negativeMinCorrections[1] = 0;
        }

        BEAM_PAINT.setStyle(Paint.Style.STROKE);
        for (Beam beam : DrawHelper.snapBeams) {
            drawBeam(beam, canvas);
        }
        BEAM_PAINT.setStyle(Paint.Style.FILL_AND_STROKE);
        for (Node node : DrawHelper.snapNodes) {
            drawNode(node, canvas);
        }

        isBeingDrawn = false;
    }

    private void drawRuler(double meterWidth, Canvas canvas) {
        canvas.drawLine((float) (SIDE_MARGIN_SCREEN_FRACTION * canvas.getWidth()), (float) (0.5 * TOP_MARGIN_SCREEN_FRACTION * canvas.getHeight()),
                (float) ((1 - SIDE_MARGIN_SCREEN_FRACTION) * canvas.getWidth()), (float) (0.5 * TOP_MARGIN_SCREEN_FRACTION * canvas.getHeight()),
                RULER_PAINT);
        canvas.drawText(Double.toString(meterWidth) + " meter(s)",
                (float) SIDE_MARGIN_SCREEN_FRACTION * canvas.getWidth(),
                (float) ((TOP_MARGIN_SCREEN_FRACTION - 0.025) * canvas.getHeight()), RULER_PAINT);
    }

    private enum Axis {
        X,
        Y
    }
}package de.ferienakademie.smartquake;


public class Tuple <T, U> {
    private T first;
    private U second;

    public Tuple(T first, U second) {
        this.first = first;
        this.second = second;
    }

    public T getFirst() {
        return first;
    }

    public void setFirst(T first) {
        this.first = first;
    }

    public U getSecond() {
        return second;
    }

    public void setSecond(U second) {
        this.second = second;
    }
}
package de.ferienakademie.smartquake.activity;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;
import android.view.ContextMenu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import android.widget.Toast;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import de.ferienakademie.smartquake.R;

public class ChooseEarthQuakeDataActivity extends AppCompatActivity {

    private int mPosition = ListView.INVALID_POSITION;

    private List<String> values = null;

    private ArrayAdapter<String> adapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_choose_data);

        values = new ArrayList<>();

        ListView lv = (ListView) findViewById(R.id.list_view_eq_data);
        registerForContextMenu( lv);
        adapter = new ArrayAdapter<String>(this, R.layout.list_item_eq_data, R.id.list_item_eq_data_text, values);
        setUpValues();
        lv.setAdapter(adapter);
        lv.setOnItemClickListener(new AdapterView.OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> adapterView, View view, int position, long l) {
                onItemSelected(position);
                mPosition = position;
            }
        });

    }

    @Override
    public void onBackPressed() {
        super.onBackPressed();
    }


    public void onItemSelected(Integer dataSourceId) {
        Intent sel = new Intent();
        sel.putExtra("eqDataFile", values.get(dataSourceId));
        setResult(Activity.RESULT_OK, sel);
        finish();
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v,
                                    ContextMenu.ContextMenuInfo menuInfo) {
        super.onCreateContextMenu(menu, v, menuInfo);

        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.menu_context_quakedata, menu);
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
        int position = info.position;
        switch(item.getItemId()) {
            case R.id.delete_quakedata:
                delete_action(position);
                return true;
            default:
                return super.onContextItemSelected(item);
        }
    }

    public void delete_action(int position){
        String name_of_file  = values.get(position) + ".earthquake";

        if (position > 1){
            File file = new File(getFilesDir().getAbsoluteFile() + "/" + name_of_file);
            boolean  deleted = false;
            if(file.exists()) {
                deleted = file.delete();
                setUpValues();
            }
            if(!deleted) {
                Log.e("Unable to delete file: " + file.getAbsolutePath(), "IOException");
            }
        }
        else {
            Toast.makeText(getApplicationContext(),
                    "You are not allowed to delete this data", Toast.LENGTH_SHORT).show();
        }

    }

    private void setUpValues() {
        values.clear();
        values.add("Sensors");
        values.add("Sinusodial");
        String[] fileNames = getFilesDir().list();
        Pattern pattern = Pattern.compile("[_A-Za-z0-9-]+\\.earthquake");
        Matcher matcher;

        for (String str : fileNames) {
            matcher = pattern.matcher(str);
            if (matcher.matches()) values.add(str.substring(0, str.length() - 11));
        }

        adapter.notifyDataSetChanged();
    }
}package de.ferienakademie.smartquake.activity;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.hardware.SensorManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.support.design.widget.CoordinatorLayout;
import android.support.design.widget.FloatingActionButton;
import android.support.design.widget.Snackbar;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.view.menu.ActionMenuItemView;
import android.util.Log;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewTreeObserver;
import android.widget.LinearLayout;
import android.widget.ProgressBar;
import android.widget.TextView;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

import de.ferienakademie.smartquake.R;
import de.ferienakademie.smartquake.Simulation;
import de.ferienakademie.smartquake.excitation.AccelData;
import de.ferienakademie.smartquake.excitation.AccelerationProvider;
import de.ferienakademie.smartquake.excitation.AccelerationProviderObserver;
import de.ferienakademie.smartquake.excitation.EmptyAccelerationProvider;
import de.ferienakademie.smartquake.excitation.FileAccelerationProvider;
import de.ferienakademie.smartquake.excitation.SensorAccelerationProvider;
import de.ferienakademie.smartquake.excitation.SinCosExcitation;
import de.ferienakademie.smartquake.fragment.SaveEarthquakeFragment;
import de.ferienakademie.smartquake.kernel1.SpatialDiscretization;
import de.ferienakademie.smartquake.kernel2.TimeIntegration;
import de.ferienakademie.smartquake.managers.PreferenceReader;
import de.ferienakademie.smartquake.model.Beam;
import de.ferienakademie.smartquake.model.Structure;
import de.ferienakademie.smartquake.model.StructureFactory;
import de.ferienakademie.smartquake.view.CanvasView;
import de.ferienakademie.smartquake.view.DrawHelper;

public class SimulationActivity extends AppCompatActivity implements Simulation.SimulationProgressListener,
        SaveEarthquakeFragment.SaveEarthquakeListener, AccelerationProviderObserver {

    // TODO: global enum for this?
    private static final int REQUEST_EARTHQUAKE_DATA = 0;
    private SensorManager mSensorManager; // manager to subscribe for sensor events
    private AccelerationProvider mCurrentAccelerationProvider = new EmptyAccelerationProvider();
    private FloatingActionButton simFab;
    private CanvasView canvasView;
    private TimeIntegration timeIntegration;
    private Structure structure;
    private SpatialDiscretization spatialDiscretization;
    private Simulation simulation;
    private CoordinatorLayout layout;
    private Snackbar slowSnackbar;
    private ProgressBar replaySeekBar;
    private TextView replayrunningLabel;
    private double replayProgress;
    private SimulationMode mode = SimulationMode.LIVE;
    //Sensor Debug Views
    private TextView tvSensorDataX;
    private TextView tvSensorDataY;
    private LinearLayout layoutSensorDebug;

    private int structureId;
    private String structureName;
    // Click listeners
    private View.OnClickListener startSimulationListener = new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            onStartButtonClicked();
        }
    };
    private View.OnClickListener stopSimulationListener = new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            onStopButtonClicked();
        }
    };
    private long lastDebugSensorDataTimestamp;

    private void runReplay(String fileName) {

        Log.d("REPLAYING", fileName);

        try {
            switch (fileName) {
                case "Sinusodial.earthquake":
                    SinCosExcitation sinCosExcitation = new SinCosExcitation();
                    sinCosExcitation.setFrequency(PreferenceReader.getExcitationFrequency());
                    startSimulation(sinCosExcitation);
                    break;
                case "Sensors.earthquake":
                    onStartButtonClicked();
                    return;
                default:
                    FileAccelerationProvider fileAccelerationProvider = new FileAccelerationProvider();
                    fileAccelerationProvider.load(openFileInput(fileName));
                    if (!fileAccelerationProvider.isEmpty()) {
                        replaySeekBar.setVisibility(View.VISIBLE);
                        startSimulation(fileAccelerationProvider);
                    } else {
                        Snackbar.make(layout, "No past acceleration data", Snackbar.LENGTH_SHORT).show();
                        return;
                    }
                    break;
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        mode = SimulationMode.REPLAY;
        replayrunningLabel.setVisibility(View.VISIBLE);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater i = getMenuInflater();
        i.inflate(R.menu.simulation_activity_actions, menu);
        return super.onCreateOptionsMenu(menu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        int id = item.getItemId();

        if (id == R.id.sim_replay_button && (simulation == null || !simulation.isRunning()) && mode != SimulationMode.REPLAY) {
            runReplay("Last.earthquake");
            if (simulation != null) toggleStartStopAvailability();
            return true;
        } else if (id == R.id.sim_load_earthquake_data_button) {
            ActionMenuItemView loadEqDataButton = (ActionMenuItemView)findViewById(id);
            if (loadEqDataButton != null) loadEqDataButton.setEnabled(false);
            ActionMenuItemView replay = (ActionMenuItemView)findViewById(R.id.sim_replay_button);
            if (replay != null) replay.setEnabled(false);
            startActivityForResult(new Intent(this, ChooseEarthQuakeDataActivity.class), REQUEST_EARTHQUAKE_DATA);
        } else if (id == R.id.save_simulation) {
            if (simulation.isRunning()) {
                simulation.stop();
            }
            new SaveEarthquakeFragment().show(getFragmentManager(), "saveEarthquake");
        } else if (id == R.id.sim_reset_button){
            if (mode != SimulationMode.LIVE) {
                mode = SimulationMode.LIVE;
            }

            if (simulation.isRunning()) {
                onStopButtonClicked();
            }
            tvSensorDataX.setText("");
            tvSensorDataY.setText("");
            createStructure(structureId, structureName);
            DrawHelper.drawStructure(structure, canvasView);
            return true;
        } else if (id == R.id.sim_replay_displacement) {
            replayDisplacement();
        }
            return super.onOptionsItemSelected(item);
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        outState.putInt("id", structureId);
        outState.putString("name", structureName);
    }

    private void createStructure(int structureId, String structureName) {
        if (structureId == 0) {
            structure = StructureFactory.cantileverBeam();
        } else if (structureId == 1) {
            structure = StructureFactory.getSimpleHouse();
        } else if (structureId == 2) {
            structure = StructureFactory.getCraneBottom();
        } else if (structureId == 3) {
            structure = StructureFactory.getBetterEiffelTower();
        } else if (structureId == 4) {
            structure = StructureFactory.getEmpireState();
        } else if (structureId == 5) {
            structure = StructureFactory.getGoldenGate();
        } else if (structureId == 6) {
            structure = StructureFactory.getWeirdBridge();
        } else if (structureId == 7) {
            structure = StructureFactory.getHousingBlock();
        } else if (structureId == 8) {
            structure = StructureFactory.getTrumpTower();
        } else if (structureId == 9) {
            structure = StructureFactory.getTVtower();
        } else if (structureId == 10) {
            structure = StructureFactory.getTaipeh();
        } else if (structureId == 11) {
            structure = StructureFactory.getHouseWithMassDamper();
        } else if (structureId == 12) {
            structure = StructureFactory.getOneWTC();
        } else if (structureId == 13) {
            structure = StructureFactory.getBurjKhalifa();
        } else if (structureId == 14) {
        structure = StructureFactory.getTunedMassExample1();
        }else if (structureId == 15) {
            structure = StructureFactory.getTunedMassExample2();
        } else if (structureId == 16) {
            structure = StructureFactory.getSimpleElephant();
        } else {
            structure = StructureFactory.getStructure(this, structureName);
        }

        for (Beam beam : structure.getBeams()) {
            beam.computeAll(structure.isLumped());
        }

    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_simulation);
        replaySeekBar = (ProgressBar) findViewById(R.id.replaySeekBar);
        replaySeekBar.setVisibility(View.GONE);

        replayrunningLabel = (TextView) findViewById(R.id.replaytext);
        replayrunningLabel.setVisibility(View.GONE);
        mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);

        simFab = (FloatingActionButton) findViewById(R.id.simFab);
        simFab.setOnClickListener(startSimulationListener);
        layout = (CoordinatorLayout) findViewById(R.id.simLayout);

        canvasView = (CanvasView) findViewById(R.id.simCanvasView);
        ViewTreeObserver viewTreeObserver = canvasView.getViewTreeObserver();

        if (savedInstanceState != null) {
            structureId = savedInstanceState.getInt("id");
            structureName = savedInstanceState.getString("name");
        }

        if (getIntent().getExtras() != null) {
            structureId = getIntent().getExtras().getInt("id");
            structureName = getIntent().getExtras().getString("name");
        }
        findSensorDataDebugViews();

        if (viewTreeObserver.isAlive()) {
            viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
                @Override
                public void onGlobalLayout() {
                    canvasView.getViewTreeObserver().removeOnGlobalLayoutListener(this);
                    createStructure(structureId, structureName);
                    DrawHelper.drawStructure(structure, canvasView);
                }
            });
        }
    }

    private void findSensorDataDebugViews() {
        layoutSensorDebug = (LinearLayout) findViewById(R.id.sim_layout_sensor_debug);
        tvSensorDataX = (TextView) findViewById(R.id.sim_tv_sensor_x);
        tvSensorDataY = (TextView) findViewById(R.id.sim_tv_sensor_y);

        int visibility = PreferenceReader.showRawSensorData() ? View.VISIBLE : View.GONE;
        layoutSensorDebug.setVisibility(visibility);
    }

    @Override
    public void onResume() {
        super.onResume();
    }

    @Override
    public void onPause() {
        super.onPause();
        onStopButtonClicked();
    }

    private void toggleStartStopAvailability() {
        if (simulation == null || simulation.isRunning()) {
            // started
            simFab.setImageResource(R.drawable.ic_pause_white_24dp);
            simFab.setOnClickListener(stopSimulationListener);
        } else {
            // stopped
            simFab.setImageResource(R.drawable.ic_play_arrow_white_24dp);
            simFab.setOnClickListener(startSimulationListener);
        }
    }

    private void onStartButtonClicked() {
        startSimulation(new SensorAccelerationProvider(mSensorManager));
    }

    void startSimulation(AccelerationProvider accelerationProvider) {
        if (mCurrentAccelerationProvider != null){
            mCurrentAccelerationProvider.removeObserver(this);
            mCurrentAccelerationProvider.setInactive();
        }

        mCurrentAccelerationProvider = accelerationProvider;
        mCurrentAccelerationProvider.addObserver(this);

        spatialDiscretization = new SpatialDiscretization(structure);
        timeIntegration = new TimeIntegration(spatialDiscretization, accelerationProvider);
        simulation = new Simulation(spatialDiscretization, timeIntegration, canvasView);

        accelerationProvider.setActive();
        accelerationProvider.initTime(30_000_000);
        simulation.start();
        simulation.setListener(this);

        toggleStartStopAvailability();
    }

    private void onStopButtonClicked() {
        if (mode == SimulationMode.REPLAY) {
            replaySeekBar.setVisibility(View.GONE);
            replayrunningLabel.setVisibility(View.GONE);
        }

        if (simulation == null) return;
        simulation.stop();
        Snackbar.make(layout, "Simulation stopped", Snackbar.LENGTH_SHORT).show();

        mCurrentAccelerationProvider.removeObserver(this);
        mCurrentAccelerationProvider.setInactive();
        if (mode == SimulationMode.LIVE) {
            try {
                mCurrentAccelerationProvider.saveFile(openFileOutput("Last.earthquake", MODE_PRIVATE));
            } catch (IOException e) {
                Log.e("ACCEL WRITE", "error writing", e);
            }
        }
        mCurrentAccelerationProvider = new EmptyAccelerationProvider();

        ActionMenuItemView loadEQDataButton = (ActionMenuItemView) findViewById(R.id.sim_load_earthquake_data_button);
        if (loadEQDataButton != null) loadEQDataButton.setEnabled(true);
        ActionMenuItemView replay = (ActionMenuItemView) findViewById(R.id.sim_replay_button);
        if (replay != null) replay.setEnabled(true);

        toggleStartStopAvailability();
    }

    @Override
    public void onSimulationFinished() {
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                simFab.setOnClickListener(startSimulationListener);
                simFab.setImageResource(R.drawable.ic_play_arrow_white_24dp);

                slowSnackbar = null;
            }
        });
    }

    @Override
    public void onSimulationStateChanged(Simulation.SimulationState newSpeedState) {

        String msg;

        if (newSpeedState == Simulation.SimulationState.RUNNING_SLOW && slowSnackbar == null) {
            msg = "Simulation speed might be slow...";
            slowSnackbar = Snackbar.make(layout, msg, Snackbar.LENGTH_INDEFINITE);
            slowSnackbar.setAction("DISMISS", new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    slowSnackbar.dismiss();
                }
            });
            slowSnackbar.show();
        }

        Log.v("SimSpeed", newSpeedState.name());

    }


    public void onNameChosen(String name) {
        FileOutputStream fileOutputStream = null;
        FileInputStream fileInputStream = null;
        try {
            fileOutputStream = openFileOutput(name + ".earthquake", Context.MODE_PRIVATE);
            fileInputStream = openFileInput("Last.earthquake");
            byte[] bytes = new byte[1024];
            int length;
            while ((length = fileInputStream.read(bytes)) > 0) {
                fileOutputStream.write(bytes, 0, length);
            }
        } catch (FileNotFoundException e) {
            Log.e("ACCEL WRITE", "file not found", e);
        } catch (IOException e) {
            Log.e("ACCEL WRITE", "error writing", e);
        } finally {
            try {
                if (fileInputStream != null) fileInputStream.close();
                if (fileOutputStream != null) fileOutputStream.close();
            } catch (IOException e) {
                Log.e("ACCEL WRITE", "error closing", e);
            }
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (resultCode == Activity.RESULT_OK && requestCode == REQUEST_EARTHQUAKE_DATA) {
            if (data.getExtras().containsKey("eqDataFile")) {
                String fileName = data.getExtras().getString("eqDataFile") + ".earthquake";
                runReplay(fileName);
            }
        }

    }

    public void onNewAccelerationValue(AccelData data) {
        long timestamp = System.currentTimeMillis();
        if (timestamp - lastDebugSensorDataTimestamp  > 100) {
            lastDebugSensorDataTimestamp = System.currentTimeMillis();
            final String xData = String.format("x: %.2f %.2f", data.xAcceleration, data.xGravity);
            final String yData = String.format("y: %.2f %.2f", data.yAcceleration, data.yGravity);
            tvSensorDataX.post(new Runnable() {
                @Override
                public void run() {
                    tvSensorDataX.setText(xData);
                    tvSensorDataY.setText(yData);
                }
            });
        }
    }

    @Override
    public void onNewReplayPercent(double percent) {
        replayProgress = percent;
        replaySeekBar.setProgress((int) Math.round(percent));
        if (percent >= 100) {
            new Handler(Looper.getMainLooper()).post(new Runnable() {
                @Override
                public void run() {
                    onStopButtonClicked();
                    mode = SimulationMode.LIVE;
                }
            });

        }
    }

    private void replayDisplacement() {
        // todo add displacement replay
    }

    // TODO: should this be part of Simulation too?
    private enum SimulationMode {
        LIVE,
        REPLAY
    }

}
package de.ferienakademie.smartquake.activity;

import android.os.Bundle;
import android.preference.PreferenceFragment;
import android.support.v7.app.AppCompatActivity;

import de.ferienakademie.smartquake.R;

public class SettingsActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Display the fragment as the main content.
        getFragmentManager().beginTransaction()
                .replace(android.R.id.content, new SettingsFragment())
                .commit();
    }


    public static class SettingsFragment extends PreferenceFragment {
        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);

            // Load the preferences from an XML resource
            addPreferencesFromResource(R.xml.preferences);
        }
    }
}

package de.ferienakademie.smartquake.activity;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;
import android.view.ContextMenu;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import android.widget.Toast;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import de.ferienakademie.smartquake.R;

/**
 * Created by root on 26.09.16.
 */
public class EarthquakeDataActivity extends AppCompatActivity {

    private int mPosition = ListView.INVALID_POSITION;

    private List<String> values = null;

    private ArrayAdapter<String> adapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_choose_data);

        values = new ArrayList<>();

        ListView lv = (ListView) findViewById(R.id.list_view_eq_data);
        registerForContextMenu( lv);
        adapter = new ArrayAdapter<String>(this, R.layout.list_item_eq_data, R.id.list_item_eq_data_text, values);
        setUpValues();
        lv.setAdapter(adapter);
        lv.setOnItemClickListener(new AdapterView.OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> adapterView, View view, int position, long l) {
                //onItemSelected(position);
                Log.v("Adapter","Just do nothing");
                mPosition = position;
            }
        });

    }

    @Override
    public void onBackPressed() {
        super.onBackPressed();
    }

    /**@Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.start, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        int id = item.getItemId();

        if (id == R.id.action_settings) {
            startActivity(new Intent(this, SettingsActivity.class));
            return true;
        }

        return super.onOptionsItemSelected(item);
    }

    public void onItemSelected(Integer dataSourceId) {
        Intent sel = new Intent();
        sel.putExtra("eqDataFile", values.get(dataSourceId));
        setResult(Activity.RESULT_OK, sel);
        finish();
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v,
                                    ContextMenu.ContextMenuInfo menuInfo) {
        super.onCreateContextMenu(menu, v, menuInfo);

        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.menu_context_quakedata, menu);
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
        int position = info.position;
        switch(item.getItemId()) {
            case R.id.delete_quakedata:
                delete_action(position);
                return true;
            default:
                return super.onContextItemSelected(item);
        }
    }

    public void delete_action(int position){
        String name_of_file  = values.get(position) + ".earthquake";

        if (position > 1){
            File file = new File(getFilesDir().getAbsoluteFile() + "/" + name_of_file);
            boolean  deleted = false;
            if(file.exists()) {
                deleted = file.delete();
                setUpValues();
            }
            if(!deleted) {
                Log.e("Unable to delete file: " + file.getAbsolutePath(), "IOException");
            }
        }
        else {
            Toast.makeText(getApplicationContext(),
                    "You are not allowed to delete this data", Toast.LENGTH_SHORT).show();
        }

    } */

    private void setUpValues() {
        values.clear();
        values.add("Sensors");
        values.add("Sinusodial");
        String[] fileNames = getFilesDir().list();
        Pattern pattern = Pattern.compile("[_A-Za-z0-9-]+\\.earthquake");
        Matcher matcher;

        for (String str : fileNames) {
            matcher = pattern.matcher(str);
            if (matcher.matches()) values.add(str.substring(0, str.length() - 11));
        }

        adapter.notifyDataSetChanged();
    }
}
package de.ferienakademie.smartquake.activity;

import android.content.Intent;
import android.os.Bundle;
import android.os.PatternMatcher;
import android.support.design.widget.FloatingActionButton;
import android.support.design.widget.NavigationView;
import android.support.v4.view.GravityCompat;
import android.support.v4.widget.DrawerLayout;
import android.support.v7.app.ActionBarDrawerToggle;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.util.Log;
import android.view.ContextMenu;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import android.widget.Toast;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import de.ferienakademie.smartquake.R;

public class StartActivity extends AppCompatActivity
        implements NavigationView.OnNavigationItemSelectedListener{

    private int mPosition = ListView.INVALID_POSITION;

    private List<String> values = null;

    private ArrayAdapter<String> adapter;

    private int fixedObjectsSize;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_start);
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);

        FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);
        fab.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //Snackbar.make(view, "You decided to draw the new model on your own", Snackbar.LENGTH_LONG).setAction("Action", null).show();
                startActivity(new Intent(StartActivity.this, CreateActivity.class));
            }
        });

        values = new ArrayList<>();

        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
        ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(
                this, drawer, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close);
        drawer.setDrawerListener(toggle);
        toggle.syncState();

        NavigationView navigationView = (NavigationView) findViewById(R.id.nav_view);
        navigationView.setNavigationItemSelectedListener(this);

        adapter = new ArrayAdapter<String>(this,
                R.layout.list_item_start_activity, R.id.list_item_date_textview, values);

        setUpValues();
        ListView mListView = (ListView) findViewById(R.id.listview_predefined);
        registerForContextMenu( mListView );
        mListView.setAdapter(adapter);
        mListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> adapterView, View view, int position, long l) {
                // CursorAdapter returns a cursor at the correct position for getItem(), or null
                // if it cannot seek to that position
                /**Cursor cursor = (Cursor) adapterView.getItemAtPosition(position);
                if (cursor != null) {
                    onItemSelected(position);
                }*/
                //String  itemValue    = (String) mListView.getItemAtPosition(position);
                onItemSelected(position);
                mPosition = position;
            }
        });

    }

    @Override
    public void onBackPressed() {
        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
        if (drawer.isDrawerOpen(GravityCompat.START)) {
            drawer.closeDrawer(GravityCompat.START);
        } else {
            super.onBackPressed();
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.start, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();

        //noinspection SimplifiableIfStatement
        if (id == R.id.action_settings) {
            startActivity(new Intent(this, SettingsActivity.class));
            return true;
        }

        return super.onOptionsItemSelected(item);
    }

    @SuppressWarnings("StatementWithEmptyBody")
    @Override
    public boolean onNavigationItemSelected(MenuItem item) {
        // Handle navigation view item clicks here.
        int id = item.getItemId();

        if (id == R.id.nav_slideshow) {
            startActivity(new Intent(this, EarthquakeDataActivity.class));
            return true;

        } else if (id == R.id.nav_manage) {
            startActivity(new Intent(this, SettingsActivity.class));
            return true;
        }

        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
        drawer.closeDrawer(GravityCompat.START);
        return true;
    }

    @Override
    protected void onResume() {
        super.onResume();
        setUpValues();
    }

    private void setUpValues() {
        values.clear();
        values.add("Simple Beam");
        values.add("Simple House");
        values.add("Crane");
        values.add("Better Eiffel Tower");
        values.add("Empire State Building");
        values.add("Golden Gate Bridge");
        values.add("A weird Bridge");
        values.add("Housing Block");
        values.add("Trump tower");
        values.add("TV Tower");
        values.add("Taipeh 101");
        values.add("House with Mass Damper");
        values.add("One World Trade Center");
        values.add("Burj Khalifa");
        values.add("TunedMassExample1");
        values.add("TunedMassExample2");
        values.add("Elephant");
        // has to be after the standard added constructions
        fixedObjectsSize = values.size();

        String[] structures = getFilesDir().list();

        Pattern pattern = Pattern.compile("[_A-Za-z0-9-]+\\.structure");
        Matcher matcher;

        for (String str : structures) {
            matcher = pattern.matcher(str);
            if (matcher.matches()) values.add(str.substring(0, str.length() - 10));
        }

        adapter.notifyDataSetChanged();
    }

    public void onItemSelected(Integer id_of_predefined_model) {
        Intent intent = new Intent(this, SimulationActivity.class);
        intent.putExtra("id", id_of_predefined_model);
        intent.putExtra("name", values.get(id_of_predefined_model) + ".structure");
        startActivity(intent);
    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v,
                                    ContextMenu.ContextMenuInfo menuInfo) {
        super.onCreateContextMenu(menu, v, menuInfo);

        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.menu_context_list, menu);
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
        int position = info.position;
        switch(item.getItemId()) {
            case R.id.delete:
                delete_action(position);
                return true;
            case R.id.edit:
                onItemSelected(position);
                return true;
            default:
                return super.onContextItemSelected(item);
        }
    }

    public void delete_action(int position){
        String name_of_file  = values.get(position) + ".structure";

        if (position >= fixedObjectsSize){
            File file = new File(getFilesDir().getAbsoluteFile() + "/" + name_of_file);
            boolean  deleted = false;
            if(file.exists()) {
                deleted = file.delete();
                setUpValues();
            }
            if(!deleted) {
                Log.e("Unable to delete file: " + file.getAbsolutePath(), "IOException");
            }
        }
        else {
            Toast.makeText(getApplicationContext(),
                    "You are not allowed to delete this model", Toast.LENGTH_SHORT).show();
        }

    }
}
package de.ferienakademie.smartquake.activity;

import android.content.Context;
import android.os.Bundle;
import android.support.v4.app.NavUtils;
import android.support.v4.view.GestureDetectorCompat;
import android.support.v7.app.ActionBar;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.util.Log;
import android.view.GestureDetector;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.ViewTreeObserver;
import android.widget.Toast;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import de.ferienakademie.smartquake.R;
import de.ferienakademie.smartquake.excitation.StructureIO;
import de.ferienakademie.smartquake.fragment.NodeFragment;
import de.ferienakademie.smartquake.fragment.SaveDialogFragment;
import de.ferienakademie.smartquake.model.Beam;
import de.ferienakademie.smartquake.model.Material;
import de.ferienakademie.smartquake.model.Node;
import de.ferienakademie.smartquake.model.Structure;
import de.ferienakademie.smartquake.view.DrawCanvasView;
import de.ferienakademie.smartquake.view.DrawHelper;

/**
 * Created by yuriy on 22/09/16.
 */
public class CreateActivity extends AppCompatActivity implements SaveDialogFragment.SaveDialogListener,
    NodeFragment.NodeParametersListener {
    private static double DELTA = 100;
    private static boolean adding = false;
    private Node node1 = null;
    private Node node2 = null;
    private Node chosenNode = null;


    private GestureDetectorCompat mGestureDetector;
    private LongPressListener longPressListener;

    private DrawCanvasView canvasView;
    private Structure structure;

    private ActionBar actionBar;

    private double width, height;

    private Material material = Material.STEEL;
    private boolean lumped = true;

    private int yOffset = 0;

    public void onNameChosen(String s) {
        serializeStructure(s);
    }

    public void onChangeNode() {
        DrawHelper.drawStructure(structure, canvasView);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_create);
        canvasView = (DrawCanvasView) findViewById(R.id.crtCanvasView);
        DrawHelper.clearCanvas(canvasView);
        structure = new Structure();
        longPressListener = new LongPressListener();
        mGestureDetector = new GestureDetectorCompat(this, longPressListener);
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar_create);
        setSupportActionBar(toolbar);
        actionBar = getSupportActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);

        ViewTreeObserver viewTreeObserver = canvasView.getViewTreeObserver();

        if (viewTreeObserver.isAlive()) {
            viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
                @Override
                public void onGlobalLayout() {
                    width = canvasView.getWidth();
                    height = canvasView.getHeight();
                }
            });
        }

        yOffset = actionBar.getHeight() + 40;

    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.create, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();
        switch(id){
            case android.R.id.home:
                NavUtils.navigateUpFromSameTask(this);
                break;
            case R.id.clear_canvas:
                structure.clearAll();
                DrawHelper.drawStructure(structure, canvasView);
                break;
            case R.id.save_canvas:
                new SaveDialogFragment().show(getFragmentManager(), "save");
                break;
        }

        return super.onOptionsItemSelected(item);
    }

    private void serializeStructure(String name) {
        List<Node> nodes = structure.getNodes();
        List<Beam> allBeams = structure.getBeams();

        for (int i = 0; i < nodes.size(); i++) {
            Node node = nodes.get(i);
            List<Beam> beams = node.getBeams();

            if (nodes.get(i).getBeams().size() == 0) {
                nodes.remove(i);
                break;
            }

            for (Beam beam : beams) {
                if (beam.getStartNode() != node && beam.getEndNode() != node) nodes.remove(i);
            }
        }

        List<Integer> condof = new ArrayList<>();
        /*
        int j = 0;
        for (int i = 0; i < nodes.size(); i++) {
            if (nodes.get(i).getCurrentY() >= height - DELTA / 2) {
                nodes.get(i).setConstraint(new boolean[] {true, true, true});
            }
        }*/

        for (Node node : nodes) {
            transformToMeters(node);
        }

        for (int i = nodes.size() - 1; i >= 0; i--) {
            if (nodes.get(i).getBeams().isEmpty()) {
                nodes.remove(i);
            }
        }

        structure.setConDOF(condof);

        for (int i = 0; i < allBeams.size(); i++) {
            if (allBeams.get(i).getStartNode().equals(allBeams.get(i).getEndNode())) allBeams.remove(i--);
        }

        FileOutputStream fileOutputStream = null;
        try {
            fileOutputStream = openFileOutput(name + ".structure", Context.MODE_PRIVATE);
            StructureIO.writeStructure(fileOutputStream, structure);
            fileOutputStream.close();
            Toast.makeText(this, "Structure saved", Toast.LENGTH_SHORT).show();
            finish();
        } catch (FileNotFoundException e) {
            Log.e("CreateActivity.class", "File not found");
        } catch (IOException e) {
            Log.e("CreateActivity.class", "IOException");
        }
    }

    public void transformToMeters(Node node) {
        double x = node.getCurrentX();
        double y = node.getCurrentY();

        double[] modelSize = {8, 8};

        double displayScaling = Math.min(0.75 * width / modelSize[0], 0.75 * height / modelSize[1]);

        double xOffset = 0.5 * (width - modelSize[0] * displayScaling);
        double yOffset = height - modelSize[1] * displayScaling;

        x = (x - xOffset) / (displayScaling);
        y = (y - yOffset) / (displayScaling);

        double temp = (height - yOffset) / (displayScaling);
        double deltaTemp = (DELTA - yOffset) / (displayScaling);

        if (y >= temp - deltaTemp / 2)   y = temp;

        node.setInitialX(x);
        node.setInitialY(y);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {

        mGestureDetector.onTouchEvent(event);

        if (event.getPointerCount() == 2) {
            if (event.getAction() == 261) {
                adding = true;

                // in pixels
                node1 = new Node(event.getX(0), (event.getY(0) - yOffset));
                node2 = new Node(event.getX(1), (event.getY(1) - yOffset));

                structure.addNode(node1);
                structure.addNode(node2);

                Beam beam = new Beam(node1, node2);
                structure.addBeam(beam);

                node1.addBeam(beam);
                node2.addBeam(beam);
                adding = false;
            }
            else if (event.getAction() == MotionEvent.ACTION_MOVE && !adding) {

                List<Node> nodes = structure.getNodes();

                node1 = nodes.get(nodes.size() - 2);
                node2 = nodes.get(nodes.size() - 1);
                node1.setInitialX(event.getX(0));
                node1.setInitialY(event.getY(0) - yOffset);

                node2.setInitialX(event.getX(1));
                node2.setInitialY(event.getY(1) - yOffset);

                Beam beam = new Beam(node1, node2);
                node1.clearBeams();
                node2.clearBeams();
                node1.addBeam(beam);
                node2.addBeam(beam);

                structure.getBeams().set(structure.getBeams().size() - 1, beam);

                magneticConnect();

            }

            if (event.getAction() == MotionEvent.ACTION_POINTER_UP
                    || event.getAction() == 262) {
                List<Node> nodes = structure.getNodes();
                List<Beam> beams = structure.getBeams();
                Node connectedOneNode = null;
                Node connectedTwoNode = null;
                Beam currBeam = structure.getBeams().get(structure.getBeams().size() - 1);
                for (int i = 0; i < nodes.size() - 2; i++) {
                    if (nodes.get(i).equals(node1)) {
                        nodes.get(i).addBeam(currBeam);
                        connectedOneNode = nodes.get(i);
                        for (int j = i + 1; j < nodes.size(); j++) {
                            if (nodes.get(j).equals(node1)) nodes.remove(j);
                        }
                    }
                    if (nodes.get(i).equals(node2)) {
                        connectedTwoNode = nodes.get(i);
                        nodes.get(i).addBeam(currBeam);
                        for (int j = i + 1; j < nodes.size(); j++) {
                            if (nodes.get(j).equals(node2)) nodes.remove(j);
                        }
                    }
                }
                for (Beam beam : beams) {
                    if (beam.getStartNode().equals(connectedOneNode))
                        beam.setStartNode(connectedOneNode);
                    if (beam.getEndNode().equals(connectedOneNode))
                        beam.setEndNode(connectedOneNode);

                    if (beam.getStartNode().equals(connectedTwoNode))
                        beam.setStartNode(connectedTwoNode);
                    if (beam.getEndNode().equals(connectedTwoNode))
                        beam.setEndNode(connectedTwoNode);
                }

                popupGround(currBeam.getStartNode());
                popupGround(currBeam.getEndNode());
            }
        }

        if (event.getPointerCount() == 1) {

            List<Node> nodes = structure.getNodes();

            double x = event.getX(0);
            double y = event.getY(0) - yOffset;

            Node tempNode = new Node(x, y);

            x = tempNode.getCurrentX();
            y = tempNode.getCurrentY();

            double mindist = DELTA;

            if (event.getAction() == MotionEvent.ACTION_DOWN) {
                for (Node node : nodes) {
                    if (distNodes(node, new Node(x, y)) <= mindist) {
                        mindist = distNodes(node, new Node(x, y));
                        chosenNode = node;
                    }
                }
            }

            if (event.getAction() == MotionEvent.ACTION_MOVE) {
                if (chosenNode != null) {
                    chosenNode.setInitialX(x);
                    chosenNode.setInitialY(y);
                    node1 = chosenNode;
                    node2 = null;
                }
                magneticConnect();
            }

            if (event.getAction() == MotionEvent.ACTION_UP && chosenNode != null) {

                List<Beam> beamList = chosenNode.getBeams();

                Node changeToThisNode = null;

                boolean removed = false;

                for (Node node : nodes) {
                    if (node.equals(chosenNode) && node != chosenNode) {
                        changeToThisNode = node;
                        break;
                    }
                }

                if (changeToThisNode != null) {
                    for (int k = 0; k < beamList.size(); k++) {
                        Beam beam = beamList.get(k);
                        if (beam.getStartNode().equals(changeToThisNode) && changeToThisNode != beam.getStartNode()) {
                            Node startNode = beam.getStartNode();
                            if (!removed) {
                                for (int i = 0; i < nodes.size(); i++) {
                                    if (startNode == nodes.get(i)) {
                                        nodes.remove(i);
                                        removed = true;
                                        if (beam.getStartNode().equals(beam.getEndNode())) {
                                            boolean delete = true;
                                            for (Beam connectedBeam : beam.getStartNode().getBeams()) {
                                                if (!connectedBeam.getStartNode().equals(connectedBeam.getEndNode()))
                                                    delete = false;
                                            }
                                            for (Beam connectedBeam : beam.getEndNode().getBeams()) {
                                                if (!connectedBeam.getStartNode().equals(connectedBeam.getEndNode()))
                                                    delete = false;
                                            }
                                            if (delete) {
                                                nodes.remove(beam.getStartNode());
                                                nodes.remove(beam.getEndNode());
                                                beamList.remove(beam);
                                            }
                                        }
                                        break;
                                    }
                                }
                            }
                            beam.setStartNode(changeToThisNode);
                            changeToThisNode.addBeam(beam);
                        }
                        if (beam.getEndNode().equals(changeToThisNode) && changeToThisNode != beam.getEndNode()) {
                            Node endNode = beam.getEndNode();
                            if (!removed) {
                                for (int i = 0; i < nodes.size(); i++) {
                                    if (endNode == nodes.get(i)) {
                                        nodes.remove(i);
                                        removed = true;
                                        if (beam.getEndNode().equals(beam.getEndNode())) {
                                            boolean delete = true;
                                            for (Beam connectedBeam : beam.getStartNode().getBeams()) {
                                                if (!connectedBeam.getStartNode().equals(connectedBeam.getEndNode()))
                                                    delete = false;
                                            }
                                            for (Beam connectedBeam : beam.getEndNode().getBeams()) {
                                                if (!connectedBeam.getStartNode().equals(connectedBeam.getEndNode()))
                                                    delete = false;
                                            }
                                            if (delete) {
                                                nodes.remove(beam.getStartNode());
                                                nodes.remove(beam.getEndNode());
                                                beamList.remove(beam);
                                            }
                                        }
                                        break;
                                    }
                                }
                            }
                            beam.setEndNode(changeToThisNode);
                            changeToThisNode.addBeam(beam);
                        }
                    }
                }

                popupGround(chosenNode);

                chosenNode = null;
            }

        }

        DrawHelper.clearCanvas(canvasView);
        DrawHelper.drawStructure(structure, canvasView);

        return super.onTouchEvent(event);
    }

    private void magneticConnect() {
        List<Node> nodes = structure.getNodes();

        boolean attach1 = false, attach2 = false;
        double minDist1 = DELTA, minDist2 = DELTA;
        Node node1Attach = null, node2Attach = null;

        for (int i = 0; i < nodes.size(); i++) {

            Node node = nodes.get(i);

            if (node1 != null && node != node1 && distNodes(node1, node) <= minDist1) {
                minDist1 = distNodes(node1, node);
                attach1 = true;
                node1Attach = node;
            }

            if (node2 != null && node != node2 && distNodes(node2, node) <= minDist2) {
                minDist2 = distNodes(node2, node);
                attach2 = true;
                node2Attach = node;
            }

        }

        if (attach1) {
            node1.setInitialX(node1Attach.getCurrentX());
            node1.setInitialY(node1Attach.getCurrentY());
        }

        if (attach2) {
            node2.setInitialX(node2Attach.getCurrentX());
            node2.setInitialY(node2Attach.getCurrentY());
        }

        if (node1 != null && node1.getCurrentY() >= height - DELTA / 2) {
            node1.setInitialY(height);

        }

        if (node2 != null && node2.getCurrentY() >= height - DELTA / 2) {
            node2.setInitialY(height);
        }

    }

    private static double distNodes(Node node1, Node node2) {
        return Math.abs(node1.getCurrentX() - node2.getCurrentX()) + Math.abs(node1.getCurrentY() - node2.getCurrentY());
    }


    public void deleteBeam(double x, double y) {

        List<Beam> beams = structure.getBeams();

        Beam deleteBeam = null;

        double minDist = DELTA;

        for (Beam beam : beams) {

            Node node1 = beam.getStartNode();
            Node node2 = beam.getEndNode();

            double x1 = node1.getCurrentX();
            double x2 = node2.getCurrentX();
            double y1 = node1.getCurrentY();
            double y2 = node2.getCurrentY();

            x2 = x2 - x1;
            x1 = x - x1;
            y2 = y2 - y1;
            y1 = y - y1;

            double cosAlfa = (x1*x2+y1*y2)/(Math.sqrt(y1*y1+x1*x1)*Math.sqrt(y2*y2+x2*x2));
            double sinAlfa = Math.sqrt(1 - cosAlfa*cosAlfa);

            double dist = sinAlfa * Math.sqrt(y1*y1+x1*x1);

            if (dist <= minDist) {
                sinAlfa = Math.abs(y2)/(Math.sqrt(y2*y2+x2*x2));
                cosAlfa = Math.sqrt(1 - sinAlfa*sinAlfa);

                x1 = rotateX(node1, cosAlfa, sinAlfa);
                x2 = rotateX(node2, cosAlfa, sinAlfa);

                x = rotateX(new Node(x, y), cosAlfa, sinAlfa);

                if (x >= Math.min(x1, x2) && x <= Math.max(x1, x2)) {
                    minDist = dist;
                    deleteBeam = beam;
                }
            }
        }

        for (int i = 0; i < beams.size(); i++) {
            if (beams.get(i) == deleteBeam) {
                beams.remove(i);
                Node startNode = deleteBeam.getStartNode();
                Node endNode = deleteBeam.getEndNode();
                // delete reference of the deleted beam on start and end nodes

                startNode.getBeams().remove(deleteBeam);
                endNode.getBeams().remove(deleteBeam);

                if (startNode.getBeams().isEmpty())
                    structure.getNodes().remove(startNode);

                if (endNode.getBeams().isEmpty())
                    structure.getNodes().remove(endNode);

                break;
            }
        }

    }

    public boolean setHinge(Node finger) {
        List<Node> nodes = structure.getNodes();
        double mindist = DELTA;
        Node hingeNode = null;
        for (Node node : nodes) {
            if (distNodes(node, finger) <= mindist) {
                mindist = distNodes(node, finger);
                hingeNode = node;
            }
        }
        if (hingeNode != null) {
            nodePopup(hingeNode);
            return true;
        }
        return false;
    }

    private void nodePopup(Node node) {
        NodeFragment nodeFragment = new NodeFragment();
        nodeFragment.setNode(node);
        nodeFragment.setListener(this);
        nodeFragment.show(getFragmentManager(), "paramaters");
    }

    private void popupGround(Node node) {
        if (node.getInitialY() >= height - DELTA / 2) {
            nodePopup(node);
        }
        boolean connected = false;
        for (boolean flag : node.getConstraints()) {
            if (flag) connected = true;
        }
        if (connected && node.getInitialY() <= height - DELTA / 2) {
            nodePopup(node);
        }
    }

    private static double rotateX(Node node, double cosAlfa, double sinAlfa) {
        return cosAlfa*node.getCurrentX() + sinAlfa*node.getCurrentY();
    }

    public class LongPressListener extends GestureDetector.SimpleOnGestureListener {
        @Override
        public void onLongPress(MotionEvent e) {
            super.onLongPress(e);

            Node n = new Node(e.getX(), e.getY() - yOffset);

            if (!setHinge(n)) deleteBeam(n.getCurrentX(), n.getCurrentY());

            DrawHelper.drawStructure(structure, canvasView);
        }

        @Override
        public boolean onDown(MotionEvent event) {
            return true;
        }

    }

}
package de.ferienakademie.smartquake.kernel2;

import android.util.Log;

import org.ejml.data.DenseMatrix64F;
import org.ejml.factory.LinearSolverFactory;
import org.ejml.interfaces.linsol.LinearSolver;
import org.ejml.ops.CommonOps;

import de.ferienakademie.smartquake.excitation.AccelerationProvider;
import de.ferienakademie.smartquake.kernel1.SpatialDiscretization;
import de.ferienakademie.smartquake.managers.PreferenceReader;

/**
 * Created by Claudius, Lukas and John on 23/09/16.
 * This class implements a solver. This is a implicit solver. We use the \beta-Newmark implementation.
 * It is unconditional stable.
 */
public class Newmark extends ImplicitSolver {

    //Right and left hand side matrix
    DenseMatrix64F B; //right
    DenseMatrix64F A; //left


    //right hand side of implicit differential equation
    DenseMatrix64F RHS;
    //old load vector
    DenseMatrix64F fLoad_old;
    //old xDotDot
    DenseMatrix64F xDotDot_old;

    //Fixed time step
    double delta_t;


    /**
     *
     * @param k1
     * @param xDot
     * @param delta_t is necessary to precalculate left and right hand side
     */
    public Newmark(SpatialDiscretization k1, AccelerationProvider accelerationProvider, DenseMatrix64F xDot, double delta_t) {
        super(k1, accelerationProvider, xDot);
        //initialization
        initialize(delta_t);
    }


    /**
     * This method initializes RHS, the solverFactor, A, delta_t, B
     * @param delta_t
     */
    private void initialize(double delta_t) {
        //set gamma to 1/2, beta to 1/4
        //initialise left side matrix
        A = M.copy();

        //delta_t fixed
        this.delta_t = delta_t;

        //A is calculated
        CommonOps.addEquals(A,delta_t/2.0,C); //A = A + delta_t/2*C
        CommonOps.addEquals(A,delta_t*delta_t/4.0,K); //A = A + delta_t**2*K/4

        //LU solver
        solver = LinearSolverFactory.lu(k1.getNumberofDOF());
        solver.setA(A);

        //initialise right side matrices: F_ext - K*xDot- B*xDotDot
        B = new DenseMatrix64F(C.getNumRows(), C.getNumRows());
        CommonOps.addEquals(B,delta_t/2.0,C);
        CommonOps.addEquals(B,delta_t*delta_t/4.0,K);
        CommonOps.addEquals(B,-1,M);

        //initialize fLoad_old
        fLoad_old = new DenseMatrix64F(C.getNumRows(), 1);

    }


    /**
     * @param t
     *        global time since start in seconds
     * @param delta_t
     *        time step
     */
    @Override
    public void nextStep(double t, double delta_t) {

        xDotDot_old = xDotDot.copy();

        //Get acceleration
        //Modal analysis has diagonalized matrices. so getAcceleration isf faster
        if(PreferenceReader.useModalAnalysis()){
            getAccelerationModalAnalysis();
        }
        else{
            //normal matrices
            getAcceleration();
        }

        //Calculate velocity
        CommonOps.addEquals(xDot,delta_t/2.0,xDotDot);
        CommonOps.addEquals(xDot,delta_t/2.0,xDotDot_old);

        //Calculate displacement
        CommonOps.addEquals(x,delta_t,xDot); //x = x + delta_t*xDot
        CommonOps.addEquals(x,delta_t*delta_t/4.0,xDotDot); //x = delta_t**2*xDotDot/4
        CommonOps.addEquals(x,delta_t*delta_t/4.0,xDotDot_old); // x = x + delta_t**2*xDotDot_old/4


        //update fLoad_old
        fLoad_old = fLoad.copy();
        //diagonalizes everything
    }


    /**
     * This method gets the acceleration. It will be written in place into xDotDot
     * It is calculated out of fload Vec
     */
    private void getAcceleration(){

        //initialize right hand side
        RHS = fLoad.copy();

        //Calculate RHS
        CommonOps.multAdd(-delta_t,K,xDot,RHS); //RHS = RHS - delta_t*K*xDot
        CommonOps.multAdd(-1,B,xDotDot,RHS); //RHS = RHS - B*xDotDot
        CommonOps.addEquals(RHS,-1,fLoad_old); //RHS = RHS - fLoad_old

        //Solve to get xDotDot
        solver.solve(RHS,xDotDot); //solver.A*acc = RHS
    }


    private void getAccelerationModalAnalysis(){

        //initialize right hand side
        RHS = fLoad.copy();

        //Calculate RHS
        multAddDiagMatrix(-delta_t,K,xDot,RHS); //RHS = RHS - delta_t*K*xDot
        multAddDiagMatrix(-1,B,xDotDot,RHS); //RHS = RHS - B*xDotDot
        CommonOps.addEquals(RHS,-1,fLoad_old); //RHS = RHS - fLoad_old

        //Solve to get xDotDot; A*xDotDot = RHS
        for(int i = 0; i<RHS.getNumRows(); i++){
            xDotDot.set(i,0,RHS.get(i,0)/A.get(i,i));
        }
    }

    /**
     * result = result + skalar*matrix*vec
     * @param delta_t
     * @param matrix
     * @param vec
     * @param result
     */
    private void multAddDiagMatrix(double delta_t, DenseMatrix64F matrix, DenseMatrix64F vec, DenseMatrix64F result){
        for(int i = 0; i< k1.getNumberofUnconstraintDOF(); i++) {
            result.set(i, 0, result.get(i) - delta_t * matrix.get(i, i) * vec.get(i, 0));
        }
    }

    private void addEqualsDiagMatrix(){

    }

}
package de.ferienakademie.smartquake.kernel2;

import android.util.Log;

import org.ejml.data.DenseMatrix64F;
import org.ejml.ops.CommonOps;

import java.util.Properties;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;



import de.ferienakademie.smartquake.excitation.AccelerationProvider;
import de.ferienakademie.smartquake.kernel1.SpatialDiscretization;
import de.ferienakademie.smartquake.managers.PreferenceReader;

/**
 * This is the main class for the simulation.
 * The time integration is here managed.
 * Created by Felix Wechsler on 21/09/16.
 */
public class TimeIntegration {

    //object to obtain matrices
    SpatialDiscretization spatialDiscretization;
    //object to get sensor data
    AccelerationProvider accelerationProvider;

    // total computed time between every time step. This variable prevents computing more than GUI wants
    double t;
    // time step
    double delta_t;
    //globale time since startSimulation
    double globalTime;

    // matrices of velocity
    DenseMatrix64F xDot;

    // provides the numerical algorithm for calculating the displacement
    TimeIntegrationSolver solver;

    // manages the multi threading
    ExecutorService executorService;


    /**
     *
     * @param spatialDiscretization
     *        object to get matrices
     * @param accelerationProvider
     *        object to get accelerations from Sensors
     */
    public TimeIntegration(SpatialDiscretization spatialDiscretization, AccelerationProvider accelerationProvider) {
        this.spatialDiscretization = spatialDiscretization;
        this.accelerationProvider = accelerationProvider;
    }


    /**
     * This method is called from the Simulation class to prepare everything for simulation
     */
    public void prepareSimulation(){

        //initial condition for the velocity.
        xDot = new DenseMatrix64F(spatialDiscretization.getNumberofDOF(),1);
        //This is just temporarily. In future this should choosen in the right way
        xDot.zero();

        //fixed step size
        delta_t = 0.030;

        //give the class the time step
        //USE timestep between FRAMES
        accelerationProvider.initTime(2*delta_t*1e9);


        //if modal analysis is activated we can diagonalize the matrices
        if(PreferenceReader.useModalAnalysis()) {
            spatialDiscretization.getModalAnalysisMatrices();
        }

        //stores the numerical scheme
        solver = new Newmark(spatialDiscretization, accelerationProvider, xDot,delta_t);
        //solver = new Euler(spatialDiscretization, accelerationProvider, xDot);



        //for the parallel thread
        executorService = Executors.newSingleThreadExecutor();
    }

    public SimulationStep performSimulationStep() {
        return new SimulationStep().execute();
    }

    /**
     * Class that represents single simulation step of {@link TimeIntegration}.
     * If simulation step can not be performed during a single frame, it will be stopped.
     */
    public class SimulationStep {

        //variable which can stop the simulation
        //it will be set to false if the calculation of the displacements takes longer than than
        boolean isRunning;
        double loadVectorScaling = PreferenceReader.getLoadVectorScaling();
        DenseMatrix64F loadVector;

        public SimulationStep execute() {
            isRunning = true;
            executorService.execute(new Runnable() {
                @Override
                public void run() {
                    long temp = System.nanoTime();
                    //reset time
                    t = 0;

                    double[] currExcitation = accelerationProvider.getAcceleration();

                   // for(int i=0; i<currExcitation.length; i++){
                   //     currExcitation[i] =0;
                   // }
                    if(PreferenceReader.useModalAnalysis()) {
                        //update loadVector
                        spatialDiscretization.updateLoadVectorModalAnalysis(currExcitation);
                        //get the loadVector for the whole calculation
                        loadVector = spatialDiscretization.getRedLoadVectorModalAnalysis().copy();
                    }
                    else {
                        //update loadVector
                        spatialDiscretization.updateLoadVector(currExcitation);
                        //get the loadVector for the whole calculation
                        loadVector = spatialDiscretization.getLoadVector().copy();
                    }

                    CommonOps.scale(loadVectorScaling, loadVector);
                    solver.setFLoad(loadVector);

                    long firstTime = System.nanoTime();
                    //this loop performs the calculation
                    //it calculates one frame then it stops
                    while(t < 0.03-0.000001 && isRunning) {
                        //calculate new displacement
                        solver.nextStep(t, delta_t);
                        //add ground movement for recording
                        solver.setGroundPosition(delta_t, currExcitation);
                        t += delta_t;

                    }

                    //for the sensor team the global time since beginnig
                    globalTime += 0.03;

                    //for checking the calculation time
                    long secondTime = System.nanoTime();
                  //  Log.e("Timestamp",""+(secondTime-firstTime));

                    if(PreferenceReader.useModalAnalysis()){
                        //update the displacement in the node variables using modal analysis
                        spatialDiscretization.superimposeModalAnalyisSolutions(solver.getX(), solver.getGroundPosition());
                    }
                    else {
                        //update the displacement in the node variables
                        spatialDiscretization.updateDisplacementsOfStructure(solver.getX(), solver.getGroundPosition());
                    }
                    isRunning = false;
                    Log.i("TimeIntegration", System.nanoTime()-temp+"");
                }
            });
            return this;
        }

        public boolean isRunning() {
            return isRunning;
        }

        public void stop() {
            isRunning = false;
        }

    }
}
package de.ferienakademie.smartquake.kernel2;

import org.ejml.data.DenseMatrix64F;

import de.ferienakademie.smartquake.excitation.AccelerationProvider;
import de.ferienakademie.smartquake.kernel1.SpatialDiscretization;
import de.ferienakademie.smartquake.managers.PreferenceReader;

/**
 * Created by Felix Wechsler on 23/09/16.
 */
public class Solver implements TimeIntegrationSolver {


    AccelerationProvider accelerationProvider;

    // Acceleration
    DenseMatrix64F xDotDot;

    // Velocity
    DenseMatrix64F xDot;

    // Displacement
    DenseMatrix64F x;

    //vector for fLoad
    DenseMatrix64F fLoad;

    //Stiffness Matrix
    DenseMatrix64F K;

    //Damping Matrix
    DenseMatrix64F C;

    //Mass Matrix
    DenseMatrix64F M;

    //connection to kernel1
    SpatialDiscretization k1;

    //Ground position, velocity and acceleration
    double[] groundPosition;
    double[] groundVelocity;
    double[] groundAcceleration;

    /**
     *
     * @param k1
     *          Connection to kernel 1
     * @param xDot
     *          Stores the velocity
     */
    public Solver(SpatialDiscretization k1, AccelerationProvider accelerationProvider, DenseMatrix64F xDot) {
        this.k1 = k1;
        this.accelerationProvider = accelerationProvider;


        //x and xDot set
        this.x = new DenseMatrix64F(k1.getNumberofDOF(), 1);
        this.xDot = xDot;

        //fill xDotDot with zeros
        xDotDot = new DenseMatrix64F(k1.getNumberofDOF(), 1);
        xDotDot.zero();

        //it depends on Modal analysis which matrices we have to use
        if(PreferenceReader.useModalAnalysis()){
            this.M = k1.getMassMatrixModalAnalysis();
            this.K = k1.getStiffnessMatrixModalAnalysis();
            this.C = k1.getDampingMatrixModalAnalysis();
            x = new DenseMatrix64F(M.getNumRows(),1);
            this.xDot = new DenseMatrix64F(M.getNumRows(),1);
            xDotDot = new DenseMatrix64F(M.getNumRows(),1);

        }
        else {
            this.M = k1.getMassMatrix();
            this.K = k1.getStiffnessMatrix();
            this.C = k1.getDampingMatrix();
        }



        //create and fill fLoad vector with zeros
        fLoad = new DenseMatrix64F(k1.getNumberofDOF(),1);

        //create ground position, velocity and acceleration
        groundPosition = new double[2];
        groundVelocity = new double[2];
        groundAcceleration = new double[2];

    }

    /**
     * This method calculates the position at the new time
     * @param t
     *        global time since start in seconds
     *
     * @param deltaT
     *        time step size
     */
    public void nextStep(double t, double deltaT) {
        //will be overwritten in the subclasses
    }


    public void nextStepLumped(double t, double delta_t){
        //will be overwritten in subclasses
    }
    /**
     *
     * @return
     */
    public AccelerationProvider getAccelerationProvider() {
        return accelerationProvider;
    }

    /**
     *
     * @return
     */
    public DenseMatrix64F getFLoad(){
        return fLoad;
    }


    /**
     *
     * @param vec
     */
    @Override
    public void setFLoad(DenseMatrix64F vec) {
        fLoad = vec.copy();
    }


    public DenseMatrix64F getX(){
        return x;
    }

    public DenseMatrix64F getXDotDot(){
        return xDotDot;
    }

    public DenseMatrix64F getXDot(){
        return xDot;
    }

    public double[] getGroundPosition() { return groundPosition; }

    /**
     * Updates ground position
     * @param delta_t
     */
    public void setGroundPosition(double delta_t, double[] acc_new){

        //Initialize new acceleration and save old velocity
        double[] velo_old = groundVelocity.clone();

        //Get new velocity
        groundVelocity[0] = 0.5*delta_t*(groundAcceleration[0]+acc_new[0]);
        groundVelocity[1] = 0.5*delta_t*(groundAcceleration[1]+acc_new[1]);

        //Get new position
        groundPosition[0] = 0.5*delta_t*(velo_old[0]+groundVelocity[0]);
        groundPosition[1] = 0.5*delta_t*(velo_old[1]+groundVelocity[1]);

    }

}
package de.ferienakademie.smartquake.kernel2;

import android.util.Log;

import org.ejml.data.DenseMatrix64F;
import org.ejml.factory.LinearSolverFactory;
import org.ejml.ops.CommonOps;

import de.ferienakademie.smartquake.excitation.AccelerationProvider;
import de.ferienakademie.smartquake.kernel1.SpatialDiscretization;

/**
 * Created by Claudius, Lukas and John on 23/09/16.
 */
public class Static extends ImplicitSolver {

    /**
     *
     * @param k1
     * @param xDot
     * @param delta_t is necessary to precalculate left and right hand side
     */
    public Static(SpatialDiscretization k1, AccelerationProvider accelerationProvider, DenseMatrix64F xDot, double delta_t) {
        super(k1, accelerationProvider, xDot);
        initialize(delta_t);
    }

    //Right and left hand side matrix
    DenseMatrix64F A; //left

    //old load vector
    DenseMatrix64F fLoad_old;

    double delta_t;


    @Override
    public void nextStep(double t, double delta_t) {

        fLoad.zero();
        fLoad.set(4, 0, 0.001);

        Log.i("Solver K: ", K.toString());
        Log.i("Solver F: ", fLoad.toString());

        //Solve
        solver.solve(fLoad,x); //solver.A*acc = RHS
        Log.i("Solver: ", x.toString());

    }


    private void initialize(double delta_t) {
        //set gamma to 1/2, beta to 1/4
        //initialise left side matrix
        A = K.copy();

        this.delta_t = delta_t;


        //LU solver
        solver = LinearSolverFactory.lu(k1.getNumberofDOF());
        solver.setA(A);


        //initialize fLoad_old
        fLoad = new DenseMatrix64F(k1.getNumberofDOF(), 1);
        fLoad.zero();
    }

    /**
     *
     *
     * @return ddotx_n+1
     */
    private void getAcceleration(){


    }
}

//solver.solve(input,output);package de.ferienakademie.smartquake.kernel2;

import org.ejml.data.DenseMatrix64F;
import org.ejml.interfaces.linsol.LinearSolver;

import de.ferienakademie.smartquake.excitation.AccelerationProvider;
import de.ferienakademie.smartquake.kernel1.SpatialDiscretization;

/**
 * Created by Felix Wechsler on 23/09/16.
 */
public class ImplicitSolver extends Solver {

    /**
     *
     * @param k1
     * @param xDot
     */
    public ImplicitSolver(SpatialDiscretization k1, AccelerationProvider accelerationProvider, DenseMatrix64F xDot) {
        super(k1, accelerationProvider, xDot);
    }
    //solver for LU decomposition
    LinearSolver<DenseMatrix64F> solver;

}
package de.ferienakademie.smartquake.kernel2;

import org.ejml.data.DenseMatrix64F;
import org.ejml.ops.CommonOps;


import de.ferienakademie.smartquake.excitation.AccelerationProvider;
import de.ferienakademie.smartquake.kernel1.SpatialDiscretization;

/**
 * Created by Felix Wechsler on 21/09/16.
 */
public class Euler extends ExplicitSolver {

    /**
     *
     * @param k1
     * @param xDot
     */
    DenseMatrix64F averageXDot;
    public Euler(SpatialDiscretization k1, AccelerationProvider accelerationProvider, DenseMatrix64F xDot) {
        super(k1, accelerationProvider, xDot);
        averageXDot =xDot.copy();
    }

    @Override
    public void nextStep(double t, double delta_t) {
        //pure euler at the moment
        //store old (n-1) velocity
        getAcceleration();
        DenseMatrix64F oldxDot = xDot.copy();

        //velocity at n
        CommonOps.addEquals(xDot, delta_t, xDotDot);

        //create average matrix of velocities at step n and n+1
        //CommonOps.addEquals(averageXDot, 1, oldxDot);

        //displacement at step n+1
        CommonOps.addEquals(x, 1*delta_t, xDot);

    }



}
package de.ferienakademie.smartquake.kernel2;
import org.ejml.data.DenseMatrix64F;


/**
 * Created by Felix Wechsler on 21/09/16.
 */
public interface TimeIntegrationSolver {


    /**
     * This is a interface for the time integration solver.
     *
     * @param t
     *        global time since start in seconds
     *
     * @param delta_t
     *        time step in seconds
     *
     */
    void nextStep( double t, double delta_t);

    void nextStepLumped(double t, double delta_t);

    DenseMatrix64F getFLoad();

    void setFLoad(DenseMatrix64F vec);

    DenseMatrix64F getX();

    DenseMatrix64F getXDotDot();

    DenseMatrix64F getXDot();

    void setGroundPosition(double delta_t, double[] currExcitation);

    public double[] getGroundPosition();

    }
package de.ferienakademie.smartquake.kernel2;

import android.util.Log;

import org.ejml.data.DenseMatrix64F;
import org.ejml.factory.LinearSolverFactory;
import org.ejml.interfaces.linsol.LinearSolver;
import org.ejml.ops.CommonOps;

import de.ferienakademie.smartquake.excitation.AccelerationProvider;
import de.ferienakademie.smartquake.kernel1.SpatialDiscretization;

/**
 * Created by Felix Wechsler on 23/09/16.
 */
public class ExplicitSolver extends Solver {
    //for the direct sensor input
    double[] acceleration;

    DenseMatrix64F tempVector;
    DenseMatrix64F tempVector2;

    //to solve M * xDotDot = f(x, xDot, t)
    LinearSolver<DenseMatrix64F> linearSolverM;
    /**
     *
     * @param k1
     * @param xDot
     */
    public ExplicitSolver(SpatialDiscretization k1, AccelerationProvider accelerationProvider, DenseMatrix64F xDot) {
        super(k1, accelerationProvider, xDot);

        //sets up fast linear solver
        linearSolverM = LinearSolverFactory.chol(k1.getNumberofDOF());
//        for(int i = 0; i<k1.getNumberofDOF(); i++){
//            M.set(i,i,0.0001);
//        }
        linearSolverM.setA(M);

        tempVector = new DenseMatrix64F(k1.getNumberofDOF(),1);
        tempVector2 = new DenseMatrix64F(k1.getNumberofDOF(),1);


        C = k1.getDampingMatrix();
        K = k1.getStiffnessMatrix();

       // for(int i=0; i<k1.getNumberofDOF(); i++){
       //     K.set(i,i,K.get(i,i)*0.000000001);
       // }
        //M is inverse at the moment
        //PAY attention
        M = k1.getInverseMassMatrix();
    }


    /**
     * This method provides for all explicit solver the acceleration of all nodes
     */
    public void getAcceleration() {
        //only for testing
       //for(int i=0; i<15; i++){
       //     fLoad.set(i,0,1);
       //}

        // next steps calculating this: tempVecotr= tempVector - C*xDot - K*x
        tempVector2 = fLoad.copy();

        //multMatrices(K,x,tempVector);
        //multMatrices(C, xDot, tempVector);
        //subMatrices(tempVector,tempVector2);

        // 1.: tempVector = tempVector - C*xDot
        CommonOps.multAdd(-1, C,xDot,tempVector2);
        //2.: tempVector = tempVector - K*x
        CommonOps.multAdd(-1, K,x,tempVector2);

        xDotDot = tempVector2;
        for( int i =0; i<k1.getNumberofDOF(); i++){
            xDotDot.set(i,0, M.get(i,i)*xDotDot.get(i,0));
        }

    }


    //JUST FOR TESTING
    //DONT USE
    public void multMatrices(DenseMatrix64F matrix, DenseMatrix64F vector,  DenseMatrix64F resultVector){
        for(int i=0; i<15; i++){
            for(int j=0; j<15; j++){
                resultVector.add(i,0, -1* matrix.get(i,j)*vector.get(j,0));
            }
        }
    }

    public void subMatrices(DenseMatrix64F vector1, DenseMatrix64F resultVector){
        for(int i=0; i<15; i++){
            resultVector.set(i,0,resultVector.get(i,0)-vector1.get(i,0));
        }
    }
}
package de.ferienakademie.smartquake.kernel1;

import org.ejml.data.DenseMatrix64F;
import org.ejml.ops.CommonOps;

import java.util.List;

import de.ferienakademie.smartquake.eigenvalueProblems.GenEig;
import de.ferienakademie.smartquake.excitation.AccelerationProvider;
import de.ferienakademie.smartquake.managers.PreferenceReader;
import de.ferienakademie.smartquake.model.Beam;
import de.ferienakademie.smartquake.model.Node;
import de.ferienakademie.smartquake.model.Structure;

/**
 * Created by alex on 22.09.16.
 */
public class SpatialDiscretization {

    private DenseMatrix64F StiffnessMatrix;
    private DenseMatrix64F DampingMatrix;
    private DenseMatrix64F MassMatrix;
    private DenseMatrix64F InverseMassMatrix;
    private DenseMatrix64F LoadVector; // vector with the forces

    private DenseMatrix64F influenceVectorX;
    private DenseMatrix64F influenceVectorY;
    //private DenseMatrix64F DisplacementVector;  //project manager advice

    private double dampingCoefficient;

    //Modal Analysis part
    private DenseMatrix64F eigenvectorsmatrix;
    private DenseMatrix64F[] eigenvectors;
    private double[] eigenvalues;
    private DenseMatrix64F StiffnessMatrixModalAnalysis;
    private DenseMatrix64F MassMatrixModalAnalysis;
    private DenseMatrix64F DampingMatrixModalAnalysis;
    private double[] ReducedEigenvalues;
    private DenseMatrix64F redLoadVectorModalAnalysis;
    private  DenseMatrix64F[] Reducedeigenvectors;
    private DenseMatrix64F ReducedeigenvectorsMatrixTranspose;
    private DenseMatrix64F RedinfluenceVectorX;
    private DenseMatrix64F RedinfluenceVectorY;
    private DenseMatrix64F RedinfluenceVectorX_temp;
    private DenseMatrix64F RedinfluenceVectorY_temp;
    double a0;
    double a1;
    private int numberofDOF;

    Structure structure;
    // temporary vectors that will be scaled by acceleration
    private DenseMatrix64F influenceVectorX_temp;
    private DenseMatrix64F influenceVectorY_temp;

    public SpatialDiscretization(Structure structure) {
        this.structure = structure;
        //initialize displacement with zeros
        numberofDOF = structure.getNumberOfDOF();

        influenceVectorX = new DenseMatrix64F(getNumberofDOF(), 1);
        influenceVectorY = new DenseMatrix64F(getNumberofDOF(), 1);

        initializeMatrices();
        calculateInfluenceVector();
        calculateEigenvaluesAndVectors();

        dampingCoefficient = PreferenceReader.getDampingCoefficient();

        calculateDampingMatrix();
    }

    /**
     * return StiffnessMatrix
     */
    public DenseMatrix64F getStiffnessMatrix() {
        return StiffnessMatrix;
    }

    /**
     * return DampingMatrix
     */
    public DenseMatrix64F getDampingMatrix() {
        return DampingMatrix;
    }

    /**
     * return MassMatrix
     */
    public DenseMatrix64F getMassMatrix() {
        return MassMatrix;
    }

    /**
     * Calculate the stiffness, mass and damping matrices.
     */
    public void initializeMatrices() {
        StiffnessMatrix = new DenseMatrix64F(getNumberofDOF(), getNumberofDOF());
        MassMatrix = new DenseMatrix64F(getNumberofDOF(), getNumberofDOF());
        DampingMatrix = new DenseMatrix64F(getNumberofDOF(), getNumberofDOF());
        LoadVector = new DenseMatrix64F(getNumberofDOF(), 1);

        StiffnessMatrix.zero();
        MassMatrix.zero();


        calculateMassMatrix();
        calculateStiffnessMatrix();

    }


    public void calculateStiffnessMatrix() {
        for (int e = 0; e < structure.getBeams().size(); e++) {
            Beam beam = structure.getBeams().get(e);
            int[] dofs = beam.getDofs();
            for (int i = 0; i < 6; i++) {
                for (int j = 0; j < 6; j++) {
                    StiffnessMatrix.add(dofs[i], dofs[j], beam.getElementStiffnessMatrix_globalized().get(i, j));
                }
            }
        }
        for (int i = 0; i < structure.getConDOF().size(); i++) {
            int j = structure.getConDOF().get(i);
            for (int k = 0; k < getNumberofDOF(); k++) {
                StiffnessMatrix.set(j, k, 0.0);
                StiffnessMatrix.set(k, j, 0.0);
            }
            StiffnessMatrix.set(j, j, 11.0);
        }
    }

    public void calculateMassMatrix() {
        for (int e = 0; e < structure.getBeams().size(); e++) {
            Beam beam = structure.getBeams().get(e);
            int[] dofs = beam.getDofs();
            for (int i = 0; i < 6; i++) {
                for (int j = 0; j < 6; j++) {
                    MassMatrix.add(dofs[i], dofs[j], beam.getElementMassMatrix_globalized().get(i, j));
                }
            }
        }
        for (int i = 0; i < structure.getConDOF().size(); i++) {
            int j = structure.getConDOF().get(i);
            for (int k = 0; k < getNumberofDOF(); k++) {
                MassMatrix.set(j, k, 0.0);
                MassMatrix.set(k, j, 0.0);
            }
            MassMatrix.set(j, j, -1.0);
        }
    }

    public void calculateinverseMassMatrix() {
        if (!structure.isLumped()) {
            throw new RuntimeException("No diagonal mass matrix!");
        }
        InverseMassMatrix = new DenseMatrix64F(getNumberofDOF(), getNumberofDOF());
        InverseMassMatrix.zero();
        for (int e = 0; e < getNumberofDOF(); e++) {
            InverseMassMatrix.add(e, e, 1. / MassMatrix.get(e, e));
        }
    }

    public DenseMatrix64F getInverseMassMatrix() { // Only call for lumped cases.
        calculateinverseMassMatrix();
        return InverseMassMatrix;
    }

    public void calculateDampingMatrix() {
        DampingMatrix.zero();
        double omega1 = ReducedEigenvalues[0];
        double omega2 = ReducedEigenvalues[1];

        double a0 =  2 * dampingCoefficient * omega1 * omega2 / (omega1 + omega2);
        double a1 = 2 * dampingCoefficient / (omega1 + omega2);
        CommonOps.add(a0, MassMatrix, a1, StiffnessMatrix, DampingMatrix);
        for (int i = 0; i < structure.getConDOF().size(); i++) {
            int j = structure.getConDOF().get(i);
            for (int k = 0; k < getNumberofDOF(); k++) {
                DampingMatrix.set(j, k, 0.0);
                DampingMatrix.set(k, j, 0.0);
            }
            DampingMatrix.set(j, j, 1.0);
        }
    }

    public void calculateModalAnalysisDampingMatrix() {
        DampingMatrix.zero();
        double omega1 = ReducedEigenvalues[0];
        double omega2 = ReducedEigenvalues[1];
        double xi = 0.05;
        a0 =  2 * xi * omega1 * omega2 / (omega1 + omega2);
        a1 = 2 * xi / (omega1 + omega2);
        CommonOps.add(a0, MassMatrixModalAnalysis, a1, StiffnessMatrixModalAnalysis, DampingMatrixModalAnalysis);

    }

    public int getNumberofDOF() {
        return numberofDOF;
    }

    public int getNumberofUnconstraintDOF() {
        return getNumberofDOF() - structure.getConDOF().size();
    }

    public Structure getStructure() {
        return structure;
    }


    public void setStructure(Structure structure) {
        this.structure = structure;
    }


    public void updateDisplacementsOfStructure(DenseMatrix64F displacementVector, double[] groundDisplacement) {

        // list of constrained dofs
        List<Integer> conDOF = structure.getConDOF();

        DenseMatrix64F displacementVector2 = displacementVector.copy();

        for (int k = 0; k < conDOF.size(); k++) {
            displacementVector2.set(conDOF.get(k), 0, 0);
        }

        for (int i = 0; i < structure.getNodes().size(); i++) {
            Node node = structure.getNodes().get(i);

            List<Integer> dofsOfNode = node.getDOF();

            for (int j = 0; j < dofsOfNode.size(); j++) {
                node.setSingleDisplacement(j, displacementVector2.get(dofsOfNode.get(j), 0));
            }
            node.saveTimeStepGroundDisplacement(groundDisplacement);
            node.saveTimeStepDisplacement();
        }

    }


    public DenseMatrix64F getLoadVector() {
        return LoadVector;
    }

    public void setLoadVector(DenseMatrix64F loadVector) {
        LoadVector = loadVector;
    }

    public void calculateInfluenceVector() {

        influenceVectorX.zero();
        influenceVectorY.zero();
        for (int i = 0; i < structure.getNodes().size(); i++) {
            Node node = structure.getNodes().get(i);
            List<Integer> DOF = node.getDOF();
            int DOFx = DOF.get(0);
            int DOFy = DOF.get(1);
            influenceVectorX.add(DOFx, 0, -1); //add influence vector in x-dir
            influenceVectorY.add(DOFy, 0, -1); //add influence vector in y-dir
        }

        influenceVectorX_temp = new DenseMatrix64F(influenceVectorX.getNumRows(), 1);
        influenceVectorY_temp = new DenseMatrix64F(influenceVectorY.getNumRows(), 1);

    }


    /**
     * Update the vector with forces using the acceleration values received from the {@link AccelerationProvider}
     *
     * @param acceleration - view {@link AccelerationProvider} for details
     */
    public void updateLoadVector(double[] acceleration) {
        if (PreferenceReader.includeGravity()) {

            CommonOps.scale(acceleration[0] - acceleration[2], influenceVectorX, influenceVectorX_temp);
            CommonOps.scale(acceleration[1] - acceleration[3], influenceVectorY, influenceVectorY_temp);
            CommonOps.addEquals(influenceVectorX_temp, influenceVectorY_temp);
            CommonOps.mult(MassMatrix, influenceVectorX_temp, LoadVector);
        } else {
            CommonOps.scale(acceleration[0], influenceVectorX, influenceVectorX_temp);
            CommonOps.scale(acceleration[1], influenceVectorY, influenceVectorY_temp);
            CommonOps.addEquals(influenceVectorX_temp, influenceVectorY_temp);
            CommonOps.mult(MassMatrix, influenceVectorX_temp, LoadVector);
        }


    }


    public void updateLoadVectorModalAnalysis(double[] acceleration) {

        redLoadVectorModalAnalysis = new DenseMatrix64F(numberofDOF-structure.getConDOF().size(),1);
        if (PreferenceReader.includeGravity()) {

            CommonOps.scale(acceleration[0], RedinfluenceVectorX, RedinfluenceVectorX_temp); //influenceVectorX_temp
            CommonOps.scale(acceleration[1], RedinfluenceVectorY, RedinfluenceVectorY_temp);
            CommonOps.addEquals(RedinfluenceVectorX_temp, RedinfluenceVectorY_temp);
        } else {
            CommonOps.scale(acceleration[0], RedinfluenceVectorX, RedinfluenceVectorX_temp);
            CommonOps.scale(acceleration[1], RedinfluenceVectorY, RedinfluenceVectorY_temp);
            CommonOps.addEquals(RedinfluenceVectorX_temp, RedinfluenceVectorY_temp);
        }

        CommonOps.mult(ReducedeigenvectorsMatrixTranspose, RedinfluenceVectorX_temp, redLoadVectorModalAnalysis);

    }


    public void calculateEigenvaluesAndVectors() {
        GenEig eigen = new GenEig(StiffnessMatrix, MassMatrix); //solve GEN eigenvalues problem
        eigenvalues = eigen.getLambda();
        double[][] ev = eigen.getV();
        eigenvectorsmatrix = new DenseMatrix64F(ev);
        CommonOps.transpose(eigenvectorsmatrix, eigenvectorsmatrix); //transpose due to constructor of DenseMatrix64F in which rows and column are switched
        eigenvectors = CommonOps.columnsToVector(eigenvectorsmatrix, null);
        ReducedEigenvalues = new double[numberofDOF-structure.getConDOF().size()];

        Reducedeigenvectors = new DenseMatrix64F[numberofDOF-structure.getConDOF().size()];

        RedinfluenceVectorX = new DenseMatrix64F(numberofDOF-structure.getConDOF().size(),1);
        RedinfluenceVectorY = new DenseMatrix64F(numberofDOF-structure.getConDOF().size(),1);
        RedinfluenceVectorX_temp  = new DenseMatrix64F(numberofDOF-structure.getConDOF().size(),1);
        RedinfluenceVectorY_temp  = new DenseMatrix64F(numberofDOF-structure.getConDOF().size(),1);


        for (int i = 0; i < numberofDOF-structure.getConDOF().size(); i++) {
            Reducedeigenvectors[i]=new DenseMatrix64F(numberofDOF-structure.getConDOF().size());
        }
        int counter =0;
        // Throw away eigenvectors that belong to constraint frequencies
        for (int i = 0; i < numberofDOF; i++) {

            if (eigenvalues[i]<0){
                continue;
            }else {
                ReducedEigenvalues[counter]=eigenvalues[i];
                Reducedeigenvectors[counter] = eigenvectors[i];
                RedinfluenceVectorX.set(counter,0,influenceVectorX.get(i,0));
                RedinfluenceVectorY_temp.set(counter,0,influenceVectorY_temp.get(i,0));
                RedinfluenceVectorX_temp.set(counter,0,influenceVectorX_temp.get(i,0));
                counter++;
            }
        }
        int numberOfUnconstraintDOF = numberofDOF-structure.getConDOF().size();
        double[][] temporary = new double[numberOfUnconstraintDOF][numberOfUnconstraintDOF];
        // Throw away eigenector entries that belong to constraint dofs.
        for (int j = 0; j < numberOfUnconstraintDOF; j++) {
            int counter_k=0;
            for (int k = 0; k < numberofDOF; k++) {
                boolean isConstraint = false;
                for (int i: structure.getConDOF()) {
                    if (k == i) {
                        isConstraint = true;
                        break;
                    }
                }
                if (!isConstraint) {
                    temporary[j][counter_k++]= Reducedeigenvectors[j].get(k, 0);
                }
            }
        }
        ReducedeigenvectorsMatrixTranspose = new DenseMatrix64F(temporary);
    }


    //Normalise eigenvectors
    public void normaliseEigenvectors() {
        for (int i = 0; i < getNumberofDOF(); i++) {
            CommonOps.scale(1 / Math.sqrt(MassMatrix.get(i, i)), eigenvectors[i]);
        }
    }



    public void getModalAnalysisMatrices(){
        normaliseEigenvectors();
        StiffnessMatrixModalAnalysis = new DenseMatrix64F(numberofDOF-structure.getConDOF().size(),numberofDOF-structure.getConDOF().size());
        MassMatrixModalAnalysis = new DenseMatrix64F(numberofDOF-structure.getConDOF().size(),numberofDOF-structure.getConDOF().size());
        DampingMatrixModalAnalysis = new DenseMatrix64F(numberofDOF-structure.getConDOF().size(),numberofDOF-structure.getConDOF().size());

        for (int i = 0; i < numberofDOF-structure.getConDOF().size(); i++) {
            StiffnessMatrixModalAnalysis.set(i,i,ReducedEigenvalues[i]);
            MassMatrixModalAnalysis.set(i,i,1.0);
        }
        calculateModalAnalysisDampingMatrix();


    }
    public void superimposeModalAnalyisSolutions(DenseMatrix64F modalSolutionvector, double[] groundDisplacement){
        DenseMatrix64F DisplacementVector = new DenseMatrix64F(numberofDOF, 1);

        for (int i = 0; i < numberofDOF-structure.getConDOF().size(); i++) {
            CommonOps.add(Reducedeigenvectors[i], modalSolutionvector.get(i, 0), DisplacementVector);
        }

        DenseMatrix64F solVecCopy = new DenseMatrix64F(getNumberofUnconstraintDOF());


        for (int i = 0; i < getNumberofUnconstraintDOF(); i++) {
            CommonOps.addEquals(Reducedeigenvectors[i],modalSolutionvector.get(i,0),solVecCopy);
        }

        // Extend displacements by inserting zeros in the position of constraint dofs
        for (int i = 0; i < getNumberofUnconstraintDOF(); i++) {
            int disp = 0;
            for (int k: structure.getConDOF()) {
                if (k <= i) {
                    disp++;
                }
            }
            DisplacementVector.set(i+disp, 0, solVecCopy.get(i, 0));
        }
        updateDisplacementsOfStructure(DisplacementVector, groundDisplacement);

    }

    public DenseMatrix64F getDampingMatrixModalAnalysis() {
        return DampingMatrixModalAnalysis;
    }



    public DenseMatrix64F getRedLoadVectorModalAnalysis() {
        return redLoadVectorModalAnalysis;
    }


    public DenseMatrix64F getMassMatrixModalAnalysis() {
        return MassMatrixModalAnalysis;
    }


    public DenseMatrix64F getStiffnessMatrixModalAnalysis() {
        return StiffnessMatrixModalAnalysis;
    }

}
package de.ferienakademie.smartquake.managers;

import android.content.Context;
import android.content.SharedPreferences;
import android.preference.PreferenceManager;

public class PreferenceReader {

    private static SharedPreferences sharedPref;

    private PreferenceReader() {}

    public static void init(Context context) {
        sharedPref = PreferenceManager.getDefaultSharedPreferences(context);
    }

    public static boolean includeGravity() {
        return sharedPref.getBoolean("pref_use_gravity", false);
    }

    public static boolean useModalAnalysis() {
        return sharedPref.getBoolean("pref_modal_analysis", false);
    }

    public static double getLoadVectorScaling() {
        return (double) (5.0f * sharedPref.getFloat("loadVector_slider", 0.2f));
    }

    public static double getExcitationFrequency() {
        return (double) 10.0f * sharedPref.getFloat("frequency_slider", 0.1f);
    }

    public static double getDampingCoefficient() {
        return (double) .5f * sharedPref.getFloat("damping_slider", 0.1f);
    }

    public static boolean massMatrices() {
        return sharedPref.getBoolean("pref_use_lumped", false);
    }

    public static boolean groundDisplcements() {
        return sharedPref.getBoolean("pref_show_ground_displacements", false);
    }

    public static boolean showRawSensorData() {
        return sharedPref.getBoolean("pref_show_raw_sensor_data", false);
    }
}
package de.ferienakademie.smartquake.preferenceElements;

/*
 * Copyright 2012 Jay Weisskopf
 *
 * Licensed under the MIT License (see LICENSE.txt)
 */

import android.content.Context;
import android.content.res.TypedArray;
import android.preference.DialogPreference;
import android.util.AttributeSet;
import android.util.Log;
import android.view.View;
import android.widget.SeekBar;
import android.widget.TextView;

import de.ferienakademie.smartquake.R;

/**
 * @author Jay Weisskopf
 */
public class SliderPreference extends DialogPreference {

    protected final static int SEEKBAR_RESOLUTION = 10000;

    protected float mValue;
    protected int mSeekBarValue;
    protected CharSequence[] mSummaries;

    /**
     * @param context
     * @param attrs
     */
    public SliderPreference(Context context, AttributeSet attrs) {
        super(context, attrs);
        setup(context, attrs);
    }

    /**
     * @param context
     * @param attrs
     * @param defStyle
     */
    public SliderPreference(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        setup(context, attrs);
    }

    private void setup(Context context, AttributeSet attrs) {
        setDialogLayoutResource(R.layout.slider_preference_dialog);
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SliderPreference);
        try {
            setSummary(a.getTextArray(R.styleable.SliderPreference_android_summary));
        } catch (Exception e) {
            // Do nothing
        }
        a.recycle();
    }

    @Override
    protected Object onGetDefaultValue(TypedArray a, int index) {
        Log.d("Test", Float.toString(a.getFloat(index, 0)));
        return a.getFloat(index, 0);
    }

    @Override
    protected void onSetInitialValue(boolean restoreValue, Object defaultValue) {
        setValue(restoreValue ? getPersistedFloat(mValue) : (Float) defaultValue);
    }

    @Override
    public CharSequence getSummary() {
        if (mSummaries != null && mSummaries.length > 0) {
            int index = (int) (mValue * mSummaries.length);
            index = Math.min(index, mSummaries.length - 1);
            return mSummaries[index];
        } else {
            return super.getSummary();
        }
    }

    public void setSummary(CharSequence[] summaries) {
        mSummaries = summaries;
    }

    @Override
    public void setSummary(CharSequence summary) {
        super.setSummary(summary);
        mSummaries = null;
    }

    @Override
    public void setSummary(int summaryResId) {
        try {
            setSummary(getContext().getResources().getStringArray(summaryResId));
        } catch (Exception e) {
            super.setSummary(summaryResId);
        }
    }

    public float getValue() {
        return mValue;
    }

    public void setValue(float value) {
        value = Math.max(0, Math.min(value, 1)); // clamp to [0, 1]
        if (shouldPersist()) {
            persistFloat(value);
        }
        if (value != mValue) {
            mValue = value;
            notifyChanged();
        }
    }

    @Override
    protected View onCreateDialogView() {
        mSeekBarValue = (int) (mValue * SEEKBAR_RESOLUTION);
        View view = super.onCreateDialogView();
        SeekBar seekbar = (SeekBar) view.findViewById(R.id.slider_preference_seekbar);
        final TextView textView = (TextView) view.findViewById(R.id.slider_preference_value);
        textView.setText(this.getSummary());
        seekbar.setMax(SEEKBAR_RESOLUTION);
        seekbar.setProgress(mSeekBarValue);
        seekbar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {

            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {
            }

            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {
            }

            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                if (fromUser) {
                    SliderPreference.this.mSeekBarValue = progress;
                    textView.setText(mSummaries[Math.min((int) ((float) mSeekBarValue / SEEKBAR_RESOLUTION * mSummaries.length), mSummaries.length - 1)]);
                }
            }
        });
        return view;
    }

    @Override
    protected void onDialogClosed(boolean positiveResult) {
        final float newValue = (float) mSeekBarValue / SEEKBAR_RESOLUTION;
        if (positiveResult && callChangeListener(newValue)) {
            setValue(newValue);
        }
        super.onDialogClosed(positiveResult);
    }

    // TODO: Save and restore preference state.
}
package de.ferienakademie.smartquake.fragment;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.content.DialogInterface;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.EditText;

import de.ferienakademie.smartquake.R;

/**
 * Created by yuriy on 26/09/16.
 */
public class SaveEarthquakeFragment extends DialogFragment {
    public interface SaveEarthquakeListener {
        public void onNameChosen(String s);
    }



    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        AlertDialog.Builder bob = new AlertDialog.Builder(getActivity());
        LayoutInflater i = getActivity().getLayoutInflater();

        final View view = i.inflate(R.layout.dialog_save_earthquake, null);

        bob.setView(view)
                .setMessage("Earthquake name")
                .setPositiveButton("Save", new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int id) {
                        EditText t = (EditText) view.findViewById(R.id.fileNameEditor);
                        ((SaveEarthquakeListener) getActivity()).onNameChosen(t.getText().toString());
                    }
                })
                .setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int id) {

                    }
                });

        return bob.create();
    }

}package de.ferienakademie.smartquake.fragment;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.content.DialogInterface;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.EditText;

import de.ferienakademie.smartquake.R;

public class SaveDialogFragment extends DialogFragment {
public interface SaveDialogListener {
    public void onNameChosen(String s);
}



    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        AlertDialog.Builder bob = new AlertDialog.Builder(getActivity());
        LayoutInflater i = getActivity().getLayoutInflater();

        final View view = i.inflate(R.layout.dialog_save, null);

//        ((EditText)view.findViewById(R.id.fileNameEditor));

        bob.setView(view)
                .setMessage("Choose structure name")
                .setPositiveButton("Save", new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int id) {
                        // view returned is null...
                        //View v = SaveDialogFragment.this.getView();
                        EditText t = (EditText) view.findViewById(R.id.fileNameEditor);
                        ((SaveDialogListener) getActivity()).onNameChosen(t.getText().toString());
                    }
                })
                .setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int id) {

                    }
                });

        return bob.create();
    }

}
package de.ferienakademie.smartquake.fragment;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.content.DialogInterface;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.RadioButton;
import android.widget.Switch;

import de.ferienakademie.smartquake.R;
import de.ferienakademie.smartquake.model.Node;
import de.ferienakademie.smartquake.view.CanvasView;

/**
 * Created by yuriy on 27/09/16.
 */
public class NodeFragment extends DialogFragment {

    public interface NodeParametersListener {
        public void onChangeNode();
    }

    Node node = null;

    NodeParametersListener caller;

    public void setNode(Node node) { this.node = node; }
    public void setListener(NodeParametersListener caller) { this.caller = caller; }

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        final AlertDialog.Builder bob = new AlertDialog.Builder(getActivity());
        LayoutInflater i = getActivity().getLayoutInflater();

        final View view = i.inflate(R.layout.choose_node, null);

        final Switch isHingeButton = (Switch)view.findViewById(R.id.is_hinge);
        if (node.isHinge()) isHingeButton.toggle();

        final EditText massText = (EditText)view.findViewById(R.id.node_mass);
        massText.setHint(String.valueOf(node.getNodeMass()));

        final CheckBox xConst = (CheckBox)view.findViewById(R.id.checkBox_x);
        final CheckBox yConst = (CheckBox)view.findViewById(R.id.checkBox_y);
        final CheckBox rConst = (CheckBox)view.findViewById(R.id.checkBox_rot);

        xConst.setChecked(node.getConstraint(0));
        yConst.setChecked(node.getConstraint(1));
        rConst.setChecked(node.getConstraint(2));


        bob.setView(view)
                .setMessage("Node parameters")
                .setPositiveButton("Done", new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int id) {
                        node.setHinge(isHingeButton.isChecked());
                        if (!massText.getText().toString().isEmpty())
                            node.setNodeMass(Double.parseDouble(massText.getText().toString()));
                        boolean[] constraints = new boolean[] {xConst.isChecked(), yConst.isChecked(), rConst.isChecked()};
                        node.setConstraint(constraints);
                        caller.onChangeNode();
                    }
                })
                .setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int id) {

                    }
                });

        return bob.create();
    }

}package de.ferienakademie.smartquake;

import android.util.Log;

import de.ferienakademie.smartquake.kernel1.SpatialDiscretization;
import de.ferienakademie.smartquake.kernel2.TimeIntegration;
import de.ferienakademie.smartquake.view.CanvasView;
import de.ferienakademie.smartquake.view.DrawHelper;

/**
 * Class that wires everything together.
 * TODO on first run an event is thrown for slow simulation.
 */
public class Simulation {

    private int slowStateCount = 0;

    public enum SimulationState {
        RUNNING_NORMAL,
        RUNNING_SLOW,
        STOPPED
    }

    private SimulationState state;

    SpatialDiscretization spatialDiscretization;
    TimeIntegration kernel2;
    CanvasView view;
    SimulationProgressListener listener;
    public boolean isRunning() {
        return state != SimulationState.STOPPED;
    }



    public Simulation(SpatialDiscretization spatialDiscretization, TimeIntegration kernel2, CanvasView view) {
        this.spatialDiscretization = spatialDiscretization;
        this.kernel2 = kernel2;
        this.view = view;
        state = SimulationState.STOPPED;
    }

    public void start() {
        state = SimulationState.RUNNING_NORMAL;
        new Thread(new Runnable() {
            @Override
            public void run() {
                kernel2.prepareSimulation();
                TimeIntegration.SimulationStep currentStep;
                while(true) {
                    if (!isRunning()) {
                        break;
                    }
                    currentStep = kernel2.performSimulationStep();
                    try {
                        //TODO: think about dynamic frame rate
                        Thread.sleep(30);
                    } catch (InterruptedException ex) {
                        Log.e("Simulation", ex.getMessage());
                        continue;
                    }
                    while(view.isBeingDrawn) {
                        try {
                            Thread.sleep(30);
                        } catch (InterruptedException ex) {
                            Log.e("Simulation", ex.getMessage());
                        }
                    }
                    if (currentStep.isRunning()) {
                        Log.e("Simulation", "Kernel2 can not catch up the gui");

                        slowStateCount++;

                        // If the last speed state was normal and now we're slow, notify the listener
                        if (listener != null && state == SimulationState.RUNNING_NORMAL && slowStateCount > 5) {
                            state = SimulationState.RUNNING_SLOW;
                            listener.onSimulationStateChanged(state);
                        }
                        currentStep.stop();
                    }
                    DrawHelper.drawStructure(spatialDiscretization.getStructure(), view);
                }
                if (listener != null) {
                    listener.onSimulationFinished();
                }
            }

        }).start();
    }

    /**
     * Stop simulation. This will also kill all background threads.
     */
    public void stop() {
        state = SimulationState.STOPPED;
    }

    public void setListener(SimulationProgressListener listener) {
        this.listener = listener;
    }

    public interface SimulationProgressListener {

        /**
         * Is called after simulation finishes. Is called from background thread.
         */
        void onSimulationFinished();

        /**
         * Is called when the simulation speed has changed
         */
        void onSimulationStateChanged(SimulationState newSpeedState);
    }

}
package de.ferienakademie.smartquake.excitation;

/**
 * Created by simon on 26.09.16.
 */

import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;

import java.security.acl.AclEntry;
import java.util.ArrayList;

/**
 * uses the gravity sensor to get gravity
 */
public class SensorGravityProvider extends GravityProvider implements SensorEventListener {
    SensorManager manager;
    Sensor gSensor;
    private int sampleRate;
    private long baseTime;
    private ArrayList<double[]> readings;
    private ArrayList<Long> reading_ts;
    protected int currentPosition;

    public SensorGravityProvider(SensorManager manager){
        this.manager = manager;
        gSensor = manager.getDefaultSensor(Sensor.TYPE_GRAVITY);
        reading_ts = new ArrayList<>();
        readings = new ArrayList<>();
        baseTime = 0;
    }

    public void getGravity(AccelData data) {
        while (readings.size() - 1 > currentPosition
                && reading_ts.get(currentPosition) < data.timestamp) {
            ++currentPosition;
        }

        data.xGravity = readings.get(currentPosition)[0];
        data.yGravity = readings.get(currentPosition)[1];
    }

    @Override
    public void onSensorChanged(SensorEvent sensorEvent) {
            double[] currentGravity =
                    new double[]{sensorEvent.values[0], sensorEvent.values[1]};
            // put new element to the queue of sensor measurements
            reading_ts.add(sensorEvent.timestamp - baseTime);
            readings.add(currentGravity);
        }
    @Override
    public void onAccuracyChanged(Sensor sensor, int i) {
        //not used
    }

    @Override
    public void init(double timestep, long baseTime){
        readings = new ArrayList<>();
        readings.add(new double[]{0,0});
        reading_ts.add((long)0);
        sampleRate = (int)(timestep/2);
        this.baseTime = baseTime;
    }

    public void setInactive() {
        manager.unregisterListener(this);
    }

    public void setActive(){
        manager.registerListener(this, gSensor, sampleRate);
    }

}
package de.ferienakademie.smartquake.excitation;

/**
 * Created by simon on 26.09.16.
 */

/**
 * uses only software emulation to get the current gravity-values
 */
public class SoftwareGravityProvider extends GravityProvider{
    private double lastXGravity = 0;
    private double lastYGravity = 9.81;
    private final double alpha = 0.8;

    /**
     * fills in gravity properties with acceleration passed through low-frequency filter
     * @param data datastrucure with acceleretation along X,Y axis already provided
     */
    @Override
    public void getGravity(AccelData data) {
        lastXGravity = alpha * lastXGravity + (1 - alpha) * data.xAcceleration;
        lastYGravity = alpha * lastYGravity + (1 - alpha) * data.yAcceleration;

        data.xGravity = lastXGravity;
        data.yGravity = lastYGravity;
        data.xAcceleration = data.xAcceleration - lastXGravity;
        data.yAcceleration = data.yAcceleration - lastYGravity;
    }

    @Override
    public void init(double timestep, long baseTime) {
        lastYGravity = 9.81;
        lastXGravity = 0;
    }

    @Override
    public void setActive() {
        //noop
    }

    @Override
    public void setInactive() {
        //noop
    }
}
package de.ferienakademie.smartquake.excitation;

/**
 * Created by simon on 26.09.16.
 */
public abstract class GravityProvider {
    public abstract void getGravity(AccelData data);

    public abstract void init(double timestep, long baseTime);

    public abstract void setActive();

    public abstract void setInactive();

}
package de.ferienakademie.smartquake.excitation;

import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.os.SystemClock;
import android.util.Log;

import java.util.ArrayList;

/**
 * Created by David Schneller on 25.09.2016.
 */
public class SensorAccelerationProvider extends StoredAccelerationProvider implements SensorEventListener {
    private long baseTime; //in nanoseconds
    private SensorManager sensorManager;
    private Sensor accelerometer;
    private GravityProvider gravityProvider;
    private int sensorRate;
    private boolean gravityActive;

    public SensorAccelerationProvider(SensorManager sensorManager)
    {
        gravityActive = true;
        this.sensorManager = sensorManager;
        if(sensorManager.getSensorList(Sensor.TYPE_LINEAR_ACCELERATION).size() == 0){
           //gravity cannot be excluded from Sensor
            gravityProvider = new SoftwareGravityProvider();
            accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
        } else {
            // gravity can be excluded
            gravityProvider = new SensorGravityProvider(sensorManager);
            accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_LINEAR_ACCELERATION);
        }

    }

    @Override
    public void initTime(double timeStep) {
        super.initTime(timeStep);
        sensorRate = (int)(timeStep/2);
        baseTime = SystemClock.elapsedRealtimeNanos();
        readings = new ArrayList<>();
        readings.add(new AccelData());
        gravityProvider.init(sensorRate, baseTime);
    }

    @Override
    public void onSensorChanged(SensorEvent sensorEvent) {
        AccelData currentAcceleration = new AccelData(sensorEvent.values[0], sensorEvent.values[1], sensorEvent.timestamp-baseTime);
        // put new element to the queue of sensor measurements
        readings.add(currentAcceleration);
    }

    @Override
    public double[] getAcceleration(){
        return AccelData.toArray(getAccelerationMeasurement());
    }

    @Override
    public double[] getAcceleration(double time){
        return AccelData.toArray(getAccelerationMeasurement(time));
    }

    @Override
    public AccelData getAccelerationMeasurement(){
        AccelData data = super.getAccelerationMeasurement();
        if(gravityActive) {
            gravityProvider.getGravity(data);
        }
        notifyNewAccelData(data);
        return data;
    }

    @Override
    public AccelData getAccelerationMeasurement(double time){
        AccelData data = super.getAccelerationMeasurement(time);
        if(gravityActive) {
            gravityProvider.getGravity(data);
        }
        notifyNewAccelData(data);
        return data;
    }


    @Override
    public void onAccuracyChanged(Sensor sensor, int i) {
        //ignored
    }

    public void setActive()
    {
        sensorManager.registerListener(this, accelerometer, sensorRate);
        gravityProvider.setActive();
    }

    public void setInactive()
    {
        sensorManager.unregisterListener(this);
        gravityProvider.setInactive();
    }

    /**
     *
     * @param active activates gravity if true
     */
    public void setGravityActive(boolean active){
            gravityActive = true;
    }
}
package de.ferienakademie.smartquake.excitation;

import java.io.IOException;
import java.io.OutputStream;

/**
 * Created by David Schneller on 25.09.2016.
 */
public class EmptyAccelerationProvider extends AccelerationProvider {
    @Override
    public double[] getAcceleration() {
        return new double[] { Double.NaN, Double.NaN };
    }

    @Override
    public double[] getAcceleration(double time) {return new double[]{ Double.NaN, Double.NaN };}

    @Override
    public AccelData getAccelerationMeasurement() {
        return null;
    }

    @Override
    public AccelData getAccelerationMeasurement(double time) {
        return null;
    }

    @Override
    public void initTime(double timeStep) {

    }

    @Override
    public void saveFile(OutputStream outputStream) throws IOException {
        outputStream.close();
    }

    @Override
    public void setActive() {

    }

    @Override
    public void setInactive() {

    }

    @Override
    public void addObserver(AccelerationProviderObserver observer) {

    }

    @Override
    public void removeObserver(AccelerationProviderObserver observer) {

    }
}
package de.ferienakademie.smartquake.excitation;

/**
 * Created by simon on 23.09.16.
 */

import java.io.IOException;
import java.io.OutputStream;
import java.security.acl.AclEntry;

/**
 * Class for generating a "standard" earthquake
 * For now only uses sin-function default amplitude 5 and default frequency of one Hertz
 */
public class SinCosExcitation extends AccelerationProvider {
    double amplitude;
    double frequency;
    private double timestep;
    long counter;

    public SinCosExcitation(double amplitude, double frequency) {
        this.amplitude = amplitude;
        this.frequency = frequency;
        this.timestep = 30_000_000;
        this.counter = 0;
    }

    public SinCosExcitation() {
        this.amplitude = 10;
        this.frequency = 1;
        this.timestep = 30_000_000;
    }

    /**
     * produces harmonic acceleration along X axis a=sin(2*pi*f*t)
     * @return 4d vector with accelerations along X,Y axis and gravitation vector (-9.81,0)
     */
    @Override
    public double[] getAcceleration() {
        counter++;
        return AccelData.toArray(getAccelerationMeasurement());
    }

    @Override
    public double[] getAcceleration(double time) {
        counter++;
        AccelData temp = getAccelerationMeasurement(time);

        return AccelData.toArray(temp);
    }

    @Override
    /**
     * notifys the observer
     */
    public AccelData getAccelerationMeasurement() {
        counter++;
        AccelData accelData = new AccelData(Math.sin(2 * Math.PI * frequency * counter * timestep * 1e-9), 0.0,
                (long) (counter * timestep));
        notifyNewAccelData(accelData);
        return accelData;
    }

    @Override
    public AccelData getAccelerationMeasurement(double time) {
        AccelData accelData = new AccelData(Math.sin(2 * Math.PI * frequency * time), 0.0,
                (long) (time * 1e9));
        notifyNewAccelData(accelData);
        return accelData;
    }

    public void setFrequency(double frequency){
        this.frequency = frequency;
    }

    public void setAmplitude(double amplitude){
        this.amplitude = amplitude;
    }

    @Override
    public void initTime(double timeStep) {
        this.timestep = timeStep;
    }

    @Override
    public void saveFile(OutputStream outputStream) throws IOException {
        //no.
    }

    @Override
    public void setActive() {

    }

    @Override
    public void setInactive() {

    }
}
package de.ferienakademie.smartquake.excitation;

import android.util.JsonReader;
import android.util.JsonToken;
import android.util.JsonWriter;

import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import de.ferienakademie.smartquake.model.Beam;
import de.ferienakademie.smartquake.model.Node;
import de.ferienakademie.smartquake.model.Structure;

/**
 * Created by David Schneller on 23.09.2016.
 */

/**
 * used for reading and Writing structures
 */
public class StructureIO {

    public static void writeStructure(OutputStream stream, Structure structure) throws IOException {
        JsonWriter writer = new JsonWriter(new OutputStreamWriter((new BufferedOutputStream(stream))));
        writer.beginObject();
        writer.name("nodes");
        writer.beginArray();
        for (Node node : structure.getNodes())
        {
            writeNode(writer, node);
        }
        writer.endArray();
        writer.name("beams");
        writer.beginArray();
        for (Beam beam : structure.getBeams())
        {
            writer.beginObject();
            writer.name("start");
            int indexStart = structure.getNodes().indexOf(beam.getStartNode());
            writer.value(indexStart);
            writer.name("end");
            int indexEnd = structure.getNodes().indexOf(beam.getEndNode());
            writer.value(indexEnd);
            writer.endObject();
        }
        writer.endArray();
        writer.endObject();
        writer.flush();
    }

    private static void writeNode(JsonWriter writer, Node node) throws IOException {
        writer.beginObject();
        writer.name("x");
        writer.value(node.getInitialX());
        writer.name("y");
        writer.value(node.getInitialY());
        writer.name("hinge");
        writer.value(node.isHinge());
        writer.name("mass");
        writer.value(node.getNodeMass());

        writer.name("constraints");
        writer.beginArray();
        for (boolean i : node.getConstraints()) {
            writer.value(i);
        }
        writer.endArray();

        writer.endObject();
    }

    private static Node parseNode(JsonReader reader) throws IOException {
        double x = Double.NaN, y = Double.NaN; double mass = 0;
        boolean hinge = false;
        boolean[] constraints = new boolean[3];
        reader.beginObject();
        while (reader.peek() != JsonToken.END_OBJECT)
        {
            String name = reader.nextName();
            switch(name)
            {
                case "x":
                    x = reader.nextDouble();
                    break;
                case "y":
                    y = reader.nextDouble();
                    break;
                case "constraints":
                    reader.beginArray();
                    int i = 0;
                    while(reader.peek() != JsonToken.END_ARRAY)
                    {
                        constraints[i++] = reader.nextBoolean();
                    }
                    reader.endArray();
                    break;
                case "hinge":
                    hinge = reader.nextBoolean();
                    break;
                case "mass":
                    mass = reader.nextDouble();
            }
        }
        reader.endObject();

        if (Double.isNaN(x) || Double.isNaN(y))
        {
            throw new IOException("Malformed file format.");
        }

        Node node = new Node(x, y);
        node.setHinge(hinge);
        node.setConstraint(constraints);
        node.setNodeMass(mass);
        return node;
    }

    private static List<Node> parseNodes(JsonReader reader) throws IOException {
        ArrayList<Node> nodes = new ArrayList<>();
        reader.beginArray();
        while (reader.peek() != JsonToken.END_ARRAY)
        {
            nodes.add(parseNode(reader));
        }
        reader.endArray();
        return nodes;
    }

    private static TemporaryBeam parseBeam(JsonReader reader) throws IOException {
        int start = -1, end = -1;

        reader.beginObject();
        while (reader.peek() != JsonToken.END_OBJECT) {
            String name = reader.nextName();
            switch (name) {
                case "start":
                    start = reader.nextInt();
                    break;
                case "end":
                    end = reader.nextInt();
                    break;
            }
        }
        reader.endObject();

        if (start == -1 || end == -1) {
            throw new IOException("Malformed file format.");
        }

        return new TemporaryBeam(start, end);
    }

    private static List<TemporaryBeam> parseBeams(JsonReader reader) throws IOException {
        ArrayList<TemporaryBeam> beams = new ArrayList<>();
        reader.beginArray();
        while (reader.peek() != JsonToken.END_ARRAY)
        {
            beams.add(parseBeam(reader));
        }
        reader.endArray();
        return beams;
    }

    public static Structure readStructure(InputStream stream) throws IOException {
        JsonReader reader = new JsonReader(new InputStreamReader(stream));
        reader.beginObject();

        List<TemporaryBeam> tempBeams = null;
        List<Node> nodes = null;
        while (reader.peek() != JsonToken.END_OBJECT) {
            String name = reader.nextName();
            switch (name) {
                case "nodes":
                    nodes = parseNodes(reader);
                    break;
                case "beams":
                    tempBeams = parseBeams(reader);
                    break;
            }
        }

        if (tempBeams == null || nodes == null) {
            throw new IOException("Malformed file format.");
        }

        List<Beam> beams = new ArrayList<>();
        for (TemporaryBeam tbeam : tempBeams) {
            Beam b = new Beam(nodes.get(tbeam.start), nodes.get(tbeam.end));
            b.setThickness(0.1f);
            beams.add(b);
        }

        Structure structure = new Structure(nodes, beams);
        return structure;
    }

    private static class TemporaryBeam {
        int start;
        int end;

        public TemporaryBeam(int start, int end)
        {
            this.start = start;
            this.end = end;
        }
    }
}
package de.ferienakademie.smartquake.excitation;

import java.io.IOException;
import java.io.OutputStream;
import java.util.LinkedList;
import java.util.List;

/**
 * Created by user on 21.09.2016.
 */

public abstract class AccelerationProvider {

    List<AccelerationProviderObserver> accelerationProviderObservers = new LinkedList<>();

    /**
     * returns acceleration reading for the next frame timestep
     * return = Fex(tp+dt), where tp - simulation time of last CALL of the function, dt - update rate of frames in nanosecs
     * has to inform the listener
     * @return first element acceleration in X axis, second element acceleration in Y axis
     *          third element gravity (acceleration) in X axis,
     *          fourth element gravity (acceleration) in Y axis
     */
    public abstract double[] getAcceleration();

    /**
     * @param time in seconds in reference frame of simulation for which value are returned
     * @return first element acceleration in X axis, second element acceleration in Y axis
     *          third element gravity (acceleration) in X axis,
     *          fourth element gravity (acceleration) in Y axis
     */
    public abstract double[] getAcceleration(double time);

    /**
     * has to inform the listener
     * @return datastructure with timestamp, X axis acceleration, Y axis acceleration
     */
    public abstract AccelData getAccelerationMeasurement();

    /**
     * datastructure with timestamp, X axis acceleration, Y axis acceleration for arbitrary simulation time
     * @param time
     * @return
     */
    public abstract AccelData getAccelerationMeasurement(double time);

    /**
     *
     * @param timeStep timeStep of the simulation in nanoseconds
     */
    public abstract void initTime(double timeStep);

    public abstract void saveFile(OutputStream outputStream) throws IOException;

    public abstract void setActive();

    public abstract void setInactive();

    public void addObserver(AccelerationProviderObserver observer) {
        if (!accelerationProviderObservers.contains(observer)) {
            accelerationProviderObservers.add(observer);
        }
    }

    public void removeObserver(AccelerationProviderObserver observer) {
        accelerationProviderObservers.remove(observer);
    }

    protected void notifyNewAccelData(AccelData data) {
        for (AccelerationProviderObserver o : accelerationProviderObservers) {
            o.onNewAccelerationValue(data);
        }
    }

    protected void notifyNewReplayPercent(double percent) {
        for (AccelerationProviderObserver o: accelerationProviderObservers) {
            o.onNewReplayPercent(percent);
        }
    }
}
package de.ferienakademie.smartquake.excitation;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Locale;

/**
 * Created by David Schneller on 25.09.2016.
 */
public abstract class StoredAccelerationProvider extends AccelerationProvider {
    //Sorry, setting protected is dirty, I know... But I do like getters/setters less.
    protected ArrayList<AccelData> readings = new ArrayList<>();
    protected int currentPosition;
    protected int tick; //current simulation tick
    protected double timeStep; //in nanoseconds

    /**
     * @param timeStep  timeStep of the simulation in nanoseconds
     */
    @Override
    public void initTime(double timeStep) {
        this.timeStep = timeStep;
        currentPosition = 0;
    }

    @Override
    public double[] getAcceleration() {
        AccelData temp = getAccelerationMeasurement();
        return new double[]{temp.xAcceleration, temp.yAcceleration, temp.xGravity, temp.yGravity};
    }

    @Override
    public double[] getAcceleration(double time) {
        while (readings.size() - 1 > currentPosition
                && readings.get(currentPosition).timestamp < (long)time*1e9) {
            ++currentPosition;
        }

        AccelData data = readings.get(currentPosition);
        return new double[]{data.xAcceleration, data.yAcceleration};
    }

    @Override
    public AccelData getAccelerationMeasurement() {
        long currTime = (long) (tick * timeStep);
        while (readings.size() - 1 > currentPosition
                && readings.get(currentPosition).timestamp < currTime) {
            ++currentPosition;
        }
        ++tick;

        return readings.get(currentPosition);
    }

    public AccelData getAccelerationMeasurement(double time){
        while (readings.size() - 1 > currentPosition
                && readings.get(currentPosition).timestamp < (long)(time * 1e9)) {
            ++currentPosition;
        }

        return readings.get(currentPosition);
    }

    /**
     * Store the data to a file
     * @param outputStream reference to a stream passing readings to internal storage
     */
    public void saveFile(OutputStream outputStream) throws IOException {
        String readingString;
        OutputStreamWriter outputStreamReader = new OutputStreamWriter(outputStream);
        BufferedWriter bufferedWriter = new BufferedWriter(outputStreamReader);

        for (int i = 0; i < readings.size(); i++) {
            readingString = String.format(Locale.ENGLISH, "%d;%20f;%20f;%20f;%20f\n", readings.get(i).timestamp,
                    readings.get(i).xAcceleration, readings.get(i).yAcceleration,
                    readings.get(i).xGravity, readings.get(i).yGravity);
            bufferedWriter.write(readingString);
        }
        bufferedWriter.close();
        outputStreamReader.close();
        outputStream.close();
    }

    /**
     * If the given timestamp lies between to timesteps in the list this method uses linear
     * interpolation between the two values to calculate the return value
     *
     * @param queue_pos the position from which accelerometer readings will be read
     * @param timestamp time point for which interpolation of measurements are prefromed
     * @return weighted average of the two accelerometer measurements around time point of interest
     */
    protected double[] interpolate(int queue_pos, long timestamp) {
        AccelData curr = readings.get(queue_pos);
        AccelData prev = readings.get(queue_pos - 1);
        long factor = (timestamp - prev.timestamp) / (curr.timestamp - prev.timestamp);
        return new double[]{prev.xAcceleration +
                (curr.xAcceleration - prev.yAcceleration) * factor,
                prev.yAcceleration + (curr.yAcceleration - prev.yAcceleration) * factor};

    }
}
package de.ferienakademie.smartquake.excitation;

/**
 * Created by user on 22.09.2016.
 */
public class AccelData implements Comparable {

    public long timestamp;
    public double xAcceleration;
    public double yAcceleration;
    public double xGravity;
    public double yGravity;

    public AccelData(){
        timestamp = 0;
        xAcceleration = 0.0;
        yAcceleration = 0.0;
        xGravity = 0.0;
        yGravity = 0.0;
    }

    public AccelData(AccelData pivotObject){
        timestamp = pivotObject.timestamp;
        xAcceleration = pivotObject.xAcceleration;
        yAcceleration = pivotObject.yAcceleration;
        xGravity = pivotObject.xGravity;
        yGravity = pivotObject.yGravity;
    }

    public AccelData(double xAccel, double yAccel, long timestamp) {
        this.xAcceleration = xAccel;
        this.yAcceleration = yAccel;
        this.timestamp = timestamp;
        xGravity = 0;
        yGravity = 0;
    }

    public AccelData(double xAccel, double yAccel, double xGravity, double yGravity, long timestamp) {
        this.xAcceleration = xAccel;
        this.yAcceleration = yAccel;
        this.xGravity = xGravity;
        this.yGravity = yGravity;
        this.timestamp = 0;
    }

    @Override
    public int compareTo(Object o) {
        return Long.compare(timestamp, ((AccelData)o).timestamp);
    }

    public static double[] toArray(AccelData data){
        return new double[]{data.xAcceleration, data.yAcceleration, data.xGravity, data.yGravity};
    }
}
package de.ferienakademie.smartquake.excitation;

/**
 * Created by Maximilian Berger on 9/26/16.
 */
public interface AccelerationProviderObserver {
    void onNewAccelerationValue(AccelData data);

    void onNewReplayPercent(double percent);
}
package de.ferienakademie.smartquake.excitation;

import android.util.Log;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;

/**
 * Created by David Schneller on 25.09.2016.
 */
public class FileAccelerationProvider extends StoredAccelerationProvider {

    public boolean isEmpty() {
        return this.readings.isEmpty();
    }

    @Override
    public double[] getAcceleration() {
        AccelData temp = super.getAccelerationMeasurement();
            double percentage = (readings.get(currentPosition).timestamp*100.0)/
                    readings.get(readings.size()-1).timestamp;
        notifyNewReplayPercent(percentage);
        notifyNewAccelData(temp);
        return AccelData.toArray(temp);
    }

    @Override
    public double[] getAcceleration(double time) {
        AccelData temp = getAccelerationMeasurement(time);
        double percentage = (readings.get(currentPosition).timestamp*100.0)/
                readings.get(readings.size()-1).timestamp;
        notifyNewAccelData(temp);
        notifyNewReplayPercent(percentage);
        return AccelData.toArray(temp);
    }

    /**
     * Load acceleration data from a file
     *
     * @param inputStream stream that passes readings from a file to excitation manager
     */
    public void load(InputStream inputStream) throws IOException {
        readings = new ArrayList<>();
        AccelData currentReading = new AccelData();
        String readingString;
        String[] readStringSplit;
        InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);

        readingString = bufferedReader.readLine();
        while (readingString != null) {
            Log.v("FILE_ACCEL", readingString);
            readStringSplit = readingString.split(";");

            currentReading.timestamp = Long.parseLong(readStringSplit[0]);
            currentReading.xAcceleration = Double.parseDouble(readStringSplit[1]);
            currentReading.yAcceleration = Double.parseDouble(readStringSplit[2]);
            currentReading.xGravity = Double.parseDouble(readStringSplit[3]);
            currentReading.yGravity = Double.parseDouble(readStringSplit[4]);

            readings.add(new AccelData(currentReading));
            readingString = bufferedReader.readLine();
        }
        bufferedReader.close();
        inputStreamReader.close();
        inputStream.close();
    }

    public void setActive() {

    }

    public void setInactive() {

    }
}
package de.ferienakademie.smartquake;

import android.app.Application;

import de.ferienakademie.smartquake.eigenvalueProblems.GenEig;
import de.ferienakademie.smartquake.managers.PreferenceReader;

public class SmartQuake extends Application {
    @Override
    public void onCreate() {
        super.onCreate();

        PreferenceReader.init(this);
    }
}
package de.ferienakademie.smartquake.eigenvalueProblems;

import java.util.ArrayList; // Variable size array to handle arbitrary dimension of input matrices

import org.ejml.data.DenseMatrix64F;
import org.netlib.util.intW;
import org.netlib.lapack.Dggev;

public class GenEig {
	/**
     *
     * Solution of generalized eigenvalue problem (AreaOfCrossSection * v = lambda * B * v)
     * using LAPACK function dggev
     *
     * Author: Vincent Stimper
     *
     * Date: 30. 8. 2016
     *
     *
	 * Arguments
	 * 		a, BreadthOfBeam						input matrices
	 *
	 * Attributes
	 * 		alphaRe, alphaIm, beta		generalized eigenvalues, beta * a * v = alpha * BreadthOfBeam * v
	 * 		v							matrix with right generalized eigenvectors as columns,
	 * 									in the same order as their eigenvalues
	 * 		n							number of dimensions
	 */

    /* Attributes */
    private ArrayList<Double> alphaRe;
    private ArrayList<Double> alphaIm;
    private ArrayList<Double> beta;
    private ArrayList<Double> v;
    private int n;

    /* Constructor */
    public GenEig(double[][] a, double[][] b) {
        this(matToVec(a),matToVec(b),a.length, true);
    }


    public GenEig(DenseMatrix64F a, DenseMatrix64F b) {
        this(a.getData(),b.getData(),a.getNumRows(), true);
    }

    public GenEig(double[] aV, double[] bV,int n, boolean sortEigenvalues) {
		/* Initialize local variables */
        this.n = n;
        double[] alphaReD = new double[n];
        double[] alphaImD = new double[n];
        double[] betaD = new double[n];
        double[] vR = new double[n * n];
        double[] vL = new double[n * n];
        double[] work = new double[8 * n];
        double[] aVWork = aV.clone();
        double[] bVWork = bV.clone();
        intW info = new intW(0);

		/* Solve generalized eigenvalue problem */
        Dggev.dggev("N", "V", n, aVWork, 0, n, bVWork, 0, n, alphaReD, 0, alphaImD, 0, betaD, 0, vL, 0, n, vR, 0, n, work, 0, 8 * n, info);

        /* Sort eigenvalues from smallest to biggest */
        if (sortEigenvalues && n > 1) {
            if (anyZero(betaD) && (! anyZero(alphaImD))) {
                System.out.println("Warning: At least one eigenvalue is complex or arbitrary. Hence, the eigenvalues cannot be sorted.");
            } else {
                double[] lambda = vecElDiv(alphaReD, betaD);
                double min;
                int minInd;
                for (int i = 0; i < n - 1; i++) {
                    min = lambda[i];
                    minInd = i;
                    for (int j = i + 1; j < n; j++) {
                        if (lambda[j] < min) {
                            min = lambda[j];
                            minInd = j;
                        }
                    }
                    lambda = switchElements(lambda, i, minInd);
                    alphaReD = switchElements(alphaReD, i, minInd);
                    betaD = switchElements(betaD, i, minInd);
                    for (int k = 0; k < n; k++) {
                        vR = switchElements(vR, i * n + k, minInd * n + k);
                    }
                }
            }
        }

        /* Assign results to attributes */
        alphaRe = vecToArrayList(alphaReD);
        alphaIm = vecToArrayList(alphaImD);
        beta = vecToArrayList(betaD);
        v = vecToArrayList(vR);
    }

    /* Getter methods */
    public double[] getAlphaRe() {
        /** Returns real part of alpha */
        return arrayListToVec(alphaRe);
    }
    public double[] getAlphaIm() {
        /** Return imaginary part of alpha */
        return arrayListToVec(alphaIm);
    }
    public double[] getBeta() {
        /** Return beta */
        return arrayListToVec(beta);
    }
    public double[][] getV() {
        /** Return eigenvectors */
        return arrayListToMat(v, n);
    }

    public double[] getV1D() {
        /** Return eigenvectors */
        return arrayListToVec(v);
    }

    public double[] getLambdaRe() {
        /** Returns real part of lambda if beta != 0 */
        double[] betaD = arrayListToVec(beta);
        if (anyZero(betaD)) {
            System.out.println("Error: At least one generalized eigenvalue is either arbitrary or not defined.");
            System.exit(0);
        }
        return vecElDiv(arrayListToVec(alphaRe), betaD);
    }
    public double[] getLambda() {
        /** Returns real part of lambda if beta != 0 *
         *  Warning: Only use this method if you are sure by theory that the eigenvalues are real! */
        double[] betaD = arrayListToVec(beta);
        if (anyZero(betaD)) {
            System.out.println("Error: At least one generalized eigenvalue is either arbitrary or not defined.");
            System.exit(0);
        }
        return vecElDiv(arrayListToVec(alphaRe), betaD);
    }
    public double[] getLambdaIm() {
        /** Returns imaginary part of lambda if beta != 0 */
        double[] betaD = arrayListToVec(beta);
        if (anyZero(betaD)) {
            System.out.println("Error: At least one generalized eigenvalue is either arbitrary or not defined.");
            System.exit(0);
        }
        return vecElDiv(arrayListToVec(alphaIm), betaD);
    }

    /* Functions */
    private static double[] matToVec(double[][] m) {
		/* Returns matrix MassPerLength as vector of columns */
        int d = m.length;
        double[] mV = new double[d * d];
        for (int i = 0; i < d; i++) {
            for (int j = 0; j < d; j++) {
                mV[i + j * d] = m[i][j];
            }
        }
        return mV;
    }
    private static ArrayList<Double> vecToArrayList(double[] v) {
		/* Returns vector v as ArrayList */
        int d = v.length;
        ArrayList<Double> aL = new ArrayList<Double>(d);
        for (int i = 0; i < d; i++) {
            aL.add(v[i]);
        }
        return aL;
    }
    private static double[] arrayListToVec(ArrayList<Double> aL) {
		/* Returns ArrayList aL as vector */
        int d = aL.size();
        double[] v = new double[d];
        for (int i = 0; i < d; i++) {
            v[i] = aL.get(i);
        }
        return v;
    }
    private static double[][] arrayListToMat(ArrayList<Double> aL, int d) {
		/* Returns ArrayList aL as matrix
		 * 	d	number of dimension of matrix */
        double[][] m = new double[d][d];
        for (int i = 0; i < d; i++) {
            for (int j = 0; j < d; j++) {
                m[i][j] = aL.get(i + j * d);
            }
        }
        return m;
    }
    private static double[] vecElDiv(double[] v1, double[] v2) {
		/* v1 ./ v2 */
        int d = v1.length;
        double[] v3 = new double[d];
        for (int i = 0; i < d; i++) {
            v3[i] = v1[i] / v2[i];
        }
        return v3;
    }
    private static boolean anyZero(double[] v) {
		/* true if one element of v is 0, false otherwise */
        boolean aZ = false;
        int i = 0;
        while (!aZ && i < v.length) {
            if (v[i] == 0) {
                aZ = true;
            }
            i++;
        }
        return aZ;
    }
    private static boolean allZero(double[] v) {
		/* true if all elements of v are 0, false otherwise */
        boolean aZ = true;
        int i = 0;
        while (aZ && i < v.length) {
            if (v[i] != 0) {
                aZ = false;
            }
            i++;
        }
        return aZ;
    }
    private static double[] switchElements(double[] vec, int index1, int index2) {
        double temp = vec[index1];
        vec[index1] = vec[index2];
        vec[index2] = temp;
        return vec;
    }

}
package de.ferienakademie.smartquake.eigenvalueProblems;


import java.util.ArrayList;
import org.netlib.lapack.Dgeev;
import org.netlib.util.intW;

public class Eig {
    /**
     * Solution of eigenvalue problem (AreaOfCrossSection * v = lambda * v)
     * using LAPACK function dgeev
     *
     * Author: Vincent Stimper
     *
     * Date: 31. 8. 2016
     *
     *
     * Arguments
     * 		a			input matrix
     *
     * Attributes
     * 		lambda		eigenvalues, a * v = lambda * v
     * 		v			matrix with right eigenvectors as columns,
     * 					in the same order as their eigenvalues
     * 		n			number of dimensions
     */

	/* Attributes */
    private ArrayList<Double> lambdaRe;
    private ArrayList<Double> lambdaIm;
    private ArrayList<Double> v;
    private int n;

    /* Constructor */
    public Eig(double[][] a) {
		/* Initialize local variables */
        n = a.length;
        double[] aV = Eig.matToVec(a);
        double[] lambdaReD = new double[n];
        double[] lambdaImD = new double[n];
        double[] vR = new double[n * n];
        double[] vL = new double[n * n];
        double[] work = new double[8 * n];
        intW info = new intW(0);

		/* Solve generalized eigenvalue problem */
        Dgeev.dgeev("N", "V", n, aV, 0, n, lambdaReD, 0, lambdaImD, 0, vL, 0, n, vR, 0, n, work, 0, 8 * n, info);

		/* Assign results to attributes */
        lambdaRe = Eig.vecToArrayList(lambdaReD);
        lambdaIm = Eig.vecToArrayList(lambdaImD);
        v = Eig.vecToArrayList(vR);
    }

    /* Getter methods */
    public double[] getLambdaRe() {
        /** Returns real part of lambda */
        return Eig.arrayListToVec(lambdaRe);
    }
    public double[] getLambdaIm() {
        /** Returns imaginary part of lambda */
        return Eig.arrayListToVec(lambdaIm);
    }
    public double[] getLambda() {
        /** Returns real part of lambda */
        return Eig.arrayListToVec(lambdaRe);
    }
    public double[][] getV() {
        return Eig.arrayListToMat(v, n);
    }

    /* Functions */
    private static double[] matToVec(double[][] m) {
		/* Returns matrix MassPerLength as vector of columns */
        int d = m.length;
        double[] mV = new double[d * d];
        for (int i = 0; i < d; i++) {
            for (int j = 0; j < d; j++) {
                mV[i + j * d] = m[i][j];
            }
        }
        return mV;
    }
    private static ArrayList<Double> vecToArrayList(double[] v) {
		/* Returns vector v as ArrayList */
        int d = v.length;
        ArrayList<Double> aL = new ArrayList<Double>(d);
        for (int i = 0; i < d; i++) {
            aL.add(v[i]);
        }
        return aL;
    }
    private static double[] arrayListToVec(ArrayList<Double> aL) {
		/* Returns ArrayList aL as vector */
        int d = aL.size();
        double[] v = new double[d];
        for (int i = 0; i < d; i++) {
            v[i] = aL.get(i);
        }
        return v;
    }
    private static double[][] arrayListToMat(ArrayList<Double> aL, int d) {
		/* Returns ArrayList aL as matrix
		 * 	d	number of dimension of matrix */
        double[][] m = new double[d][d];
        for (int i = 0; i < d; i++) {
            for (int j = 0; j < d; j++) {
                m[i][j] = aL.get(i + j * d);
            }
        }
        return m;
    }

}package de.ferienakademie.smartquake.model;

/**
 * Created by Maximilian Berger on 9/25/16.
 */
public class Displacements {
    private double axialDisplacementStartNode, orthogonalDisplacementStartNode, rotationStartNode,
    axialDisplacementEndNode, orthogonalDisplacementEndNode, rotationEndNode;

    public Displacements(double axialDisplacementStartNode, double orthogonalDisplacementStartNode,
                         double rotationStartNode, double axialDisplacementEndNode,
                         double orthogonalDisplacementEndNode, double rotationEndNode) {
        this.axialDisplacementStartNode = axialDisplacementStartNode;
        this.orthogonalDisplacementStartNode = orthogonalDisplacementStartNode;
        this.rotationStartNode = rotationStartNode;
        this.axialDisplacementEndNode = axialDisplacementEndNode;
        this.orthogonalDisplacementEndNode = orthogonalDisplacementEndNode;
        this.rotationEndNode = rotationEndNode;
    }

    public double getAxialDisplacementStartNode() {
        return axialDisplacementStartNode;
    }

    public void setAxialDisplacementStartNode(double axialDisplacementStartNode) {
        this.axialDisplacementStartNode = axialDisplacementStartNode;
    }

    public double getOrthogonalDisplacementStartNode() {
        return orthogonalDisplacementStartNode;
    }

    public void setOrthogonalDisplacementStartNode(double orthogonalDisplacementStartNode) {
        this.orthogonalDisplacementStartNode = orthogonalDisplacementStartNode;
    }

    public double getRotationStartNode() {
        return rotationStartNode;
    }

    public void setRotationStartNode(double rotationStartNode) {
        this.rotationStartNode = rotationStartNode;
    }

    public double getAxialDisplacementEndNode() {
        return axialDisplacementEndNode;
    }

    public void setAxialDisplacementEndNode(double axialDisplacementEndNode) {
        this.axialDisplacementEndNode = axialDisplacementEndNode;
    }

    public double getOrthogonalDisplacementEndNode() {
        return orthogonalDisplacementEndNode;
    }

    public void setOrthogonalDisplacementEndNode(double orthogonalDisplacementEndNode) {
        this.orthogonalDisplacementEndNode = orthogonalDisplacementEndNode;
    }

    public double getRotationEndNode() {
        return rotationEndNode;
    }

    public void setRotationEndNode(double rotationEndNode) {
        this.rotationEndNode = rotationEndNode;
    }
}
package de.ferienakademie.smartquake.model;

import android.content.SharedPreferences;
import android.preference.PreferenceManager;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import de.ferienakademie.smartquake.kernel1.SpatialDiscretization;
import de.ferienakademie.smartquake.managers.PreferenceReader;

/**
 * Class for the whole structure.
 */
public class Structure {

    private int numberOfDOF;
    private List<Node> nodes;
    private List<Beam> beams;

    // list of the constained dofs, set in the function StructureFactory.enumerateDOFs()
    private List<Integer> conDOF = new ArrayList<>();

    public double[] getBoundingBox() {
        return boundingBox;
    }


    // X, Y
    private double[] modelSize = {8, 8};
    // left/right X, top/bottom Y //TODO which one will be used?
    private double[] boundingBox = new double[4];

    private boolean lumped = false;  // default value!

    public Structure(List<Node> nodes, List<Beam> beams) {
        this.nodes = nodes;
        this.beams = beams;
    }

    public Structure(List<Node> nodes, List<Beam> beams, List<Integer> conDOF) {
        this.nodes = nodes;
        this.beams = beams;
        this.conDOF = conDOF;
        lumped = PreferenceReader.massMatrices();
    }

    public Structure() {
        this(new ArrayList<Node>(), new ArrayList<Beam>(), new ArrayList<Integer>());
    }

    public List<Node> getNodes() {
        return nodes;
    }

    public void addNodes(List<Node> nodes) {
        for (Node n: nodes) {
            this.addNode(n);
        }
    }

    public void addNodes(Node... nodes) {
        for (Node n: nodes) {
            this.addNode(n);
        }
    }

    public void addNode(Node node) {
        if (this.nodes.isEmpty()) {
            boundingBox[0] = node.getInitialX();
            boundingBox[1] = node.getInitialX();
            boundingBox[2] = node.getInitialY();
            boundingBox[3] = node.getInitialY();
        } else {
            if (node.getInitialX() < boundingBox[0]) {
                boundingBox[0] = node.getInitialX();
            }
            if (node.getInitialX() > boundingBox[1]) {
                boundingBox[1] = node.getInitialX();
            }
            if (node.getInitialY() < boundingBox[2]) {
                boundingBox[2] = node.getInitialY();
            }
            if (node.getInitialY() > boundingBox[3]) {
                boundingBox[3] = node.getInitialY();
            }
        }
        this.nodes.add(node);
    }


    public List<Integer> getConDOF() {
        return conDOF;
    }

    public void setConDOF(List<Integer> conDOF) {
        this.conDOF = conDOF;
    }


    public void addSingleConDOF(int conDOF) {
        this.conDOF.add(conDOF);
    }


    public void addBeams(List<Beam> beams) {
        this.beams.addAll(beams);
    }

    public void addBeams(Beam... beams) {
        Collections.addAll(this.beams, beams);
    }

    public void addBeam(Beam beam) {
        this.beams.add(beam);
    }
    
    public List<Beam> getBeams() {
        return beams;
    }

    public void clearAll() {
        nodes.clear();
        beams.clear();
    }
    public boolean isLumped() {
        return lumped;
    }

    public void setLumped(boolean lumped) {
        this.lumped = lumped;
    }

    public int getNumberOfDOF() {
        return numberOfDOF;
    }

    public void setNumberOfDOF(int numberOfDOF) {
        this.numberOfDOF = numberOfDOF;
    }
}
package de.ferienakademie.smartquake.model;

import android.content.Context;
import android.util.Log;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;

import de.ferienakademie.smartquake.excitation.StructureIO;
import de.ferienakademie.smartquake.kernel1.SpatialDiscretization;

public class StructureFactory {


    public static Structure cantileverBeam() {
        List<Integer> dofNode1 = new LinkedList<>();
        List<Integer> dofNode2 = new LinkedList<>();


        Node bottom = new Node(4, 8);
        Node up = new Node(4, 3);

        List<Integer> condof = new ArrayList<>();

        bottom.setSingleConstraint(0,true);
        bottom.setSingleConstraint(1,true);
        bottom.setSingleConstraint(2,true);


        Material testMaterial = Material.STEEL2;

        Beam b = new Beam(bottom, up, testMaterial);

        Structure structure =  new Structure(Arrays.asList(bottom, up), Arrays.asList(b), condof);
        enumerateDOFs(structure);
        return structure;
    }



    public static Structure getSimpleHouse() {
        double width = 8;
        double height = 8;

        double half = width * 0.5;

        Structure structure = new Structure();
        Material testMaterial = Material.STEEL;

        Node n1 = new Node(0, height, false);
        Node n2 = new Node(width, height, false);
        Node n3 = new Node(width, height - half, false);
        Node n4 = new Node(0, height - half, false);
        Node n5 = new Node(half, height - 2 * half, false);

        Beam b2 = new Beam(n2, n3, testMaterial);
        Beam b3 = new Beam(n3, n4, testMaterial);
        Beam b4 = new Beam(n4, n1, testMaterial);
        Beam b5 = new Beam(n4, n5, testMaterial);
        Beam b6 = new Beam(n5, n3, testMaterial);

        structure.addNodes(n1, n2, n3, n4, n5);
        structure.addBeams( b2, b3, b4, b5, b6);

        boolean[] con = new boolean[3];
        con[0]=true;
        con[1]=true;
        con[2]=true;

        n1.setConstraint(con);
        n2.setConstraint(con);
        enumerateDOFs(structure);
        return structure;
    }

    public static Structure getTunedMassExample1() {
        double width = 8;
        double height = 8;

        double half = width * 0.5;

        Structure structure = new Structure();
        Material testMaterial = Material.STEEL3;

        Node n1 = new Node(0, height, false);
        Node n2 = new Node(width, height, false);
        Node n3 = new Node(width, height - 2*half, false);
        Node n4 = new Node(0, height - 2*half, false);
        Node n5 = new Node(width/2, height - 2*half, false);
        Node n6 = new Node(width/2, height - half, 50);





        Beam b2 = new Beam(n2, n3, testMaterial);
        Beam b3 = new Beam(n3, n5, testMaterial);
        Beam b4 = new Beam(n5, n4, testMaterial);
        Beam b5 = new Beam(n4, n1, testMaterial);
        Beam b6 = new Beam(n5, n6, testMaterial);

        structure.addNodes(n1, n2, n3, n4,n5,n6);
        structure.addBeams( b2, b3, b4,b5,b6);

        boolean[] con = new boolean[3];
        con[0]=true;
        con[1]=true;
        con[2]=true;

        n1.setConstraint(con);
        n2.setConstraint(con);
        n5.setHinge(true    );
        enumerateDOFs(structure);
        return structure;
    }

    public static Structure getTunedMassExample2() {
        double width = 8;
        double height = 8;

        double half = width * 0.5;

        Structure structure = new Structure();
        Material testMaterial = Material.STEEL3;

        Node n1 = new Node(0, height, false);
        Node n2 = new Node(width, height, false);
        Node n3 = new Node(width, height - 2*half, false);
        Node n4 = new Node(0, height - 2*half, false);
        Node n5 = new Node(width/2, height - 2*half, false);

        Beam b2 = new Beam(n2, n3, testMaterial);
        Beam b3 = new Beam(n3, n5, testMaterial);
        Beam b4 = new Beam(n5, n4, testMaterial);
        Beam b5 = new Beam(n4, n1, testMaterial);

        structure.addNodes(n1, n2, n3, n4,n5);
        structure.addBeams( b2, b3, b4,b5);

        boolean[] con = new boolean[3];
        con[0]=true;
        con[1]=true;
        con[2]=true;

        n1.setConstraint(con);
        n2.setConstraint(con);
        n5.setHinge(true    );
        enumerateDOFs(structure);
        return structure;
    }

    public static Structure getHouseWithMassDamper() {
        double width = 8;
        double height = 8;

        Structure structure = new Structure();
        Material testMaterial = Material.STEEL;

        Node n1 = new Node(0, height);
        Node n2 = new Node(width, height);
        Node n3 = new Node(width, height/2);
        Node n4 = new Node(0, height/2);
        Node n5 = new Node(width/2, 0,true);
        Node n6 = new Node(width/2, height*1/4,10);
        n6.setNodeMass(10000000);
        Beam b2 = new Beam(n2, n3, testMaterial);
        Beam b3 = new Beam(n3, n4, testMaterial);
        Beam b4 = new Beam(n4, n1, testMaterial);
        Beam b5 = new Beam(n4, n5, testMaterial);
        Beam b6 = new Beam(n5, n3, testMaterial);
        Beam b7 = new Beam(n5, n6, testMaterial);

        structure.addNodes(n1, n2, n3, n4, n5, n6);
        structure.addBeams( b2, b3, b4, b5, b6, b7);

        boolean[] con = new boolean[3];
        con[0]=true;
        con[1]=true;
        con[2]=true;

        n1.setConstraint(con);
        n2.setConstraint(con);
        enumerateDOFs(structure);
        return structure;
    }

    public static Structure getCraneBottom() {

        double width = 8;
        double height = 24;

        Structure structure = new Structure();
        Material testMaterial = Material.STEEL;


        Node n1 = new Node(0, height);
        Node n2 = new Node(width, height);
        Node n3 = new Node(0, height - width);
        Node n4 = new Node(width, height - width);
        Node n5 = new Node(0, height - 2 * width);
        Node n6 = new Node(width, height - 2 * width);
        Node n7 = new Node(0, height - 3 * width);
        Node n8 = new Node(width, height - 3 * width);

        Beam b1 = new Beam(n1, n3, testMaterial);
        Beam b2 = new Beam(n3, n5, testMaterial);
        Beam b3 = new Beam(n5, n7, testMaterial);
        Beam b4 = new Beam(n7, n8, testMaterial);
        Beam b5 = new Beam(n8, n6, testMaterial);
        Beam b6 = new Beam(n6, n4, testMaterial);
        Beam b7 = new Beam(n4, n2, testMaterial);
        Beam b8 = new Beam(n2, n3, testMaterial);
        Beam b9 = new Beam(n4, n5, testMaterial);
        Beam b10 = new Beam(n6, n7, testMaterial);
        Beam b11 = new Beam(n3, n4, testMaterial);
        Beam b12 = new Beam(n5, n6, testMaterial);

        structure.addNodes(n1, n2, n3, n4, n5, n6, n7, n8);
        structure.addBeams(b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12);

        boolean[] con = new boolean[3];
        con[0]=true;
        con[1]=true;
        con[2]=true;

        n1.setConstraint(con);
        n2.setConstraint(con);
        enumerateDOFs(structure);
        return structure;

    }

    public static Structure getBetterEiffelTower() {
        double a = 1;
        double width = 6 * a;
        double height = 16 * a;

        Structure structure = new Structure();
        Material testMaterial = Material.STEEL;


        Node n1 = new Node(0, height);
        Node n2 = new Node(a, height);
        Node n3 = new Node(width - a, height);
        Node n4 = new Node(width, height);
        Node n5 = new Node(a, height - 2 * a);
        Node n6 = new Node(2 * a, height - 2 * a);
        Node n7 = new Node(width - 2 * a, height - 2 * a);
        Node n8 = new Node(width - a, height - 2 * a);
        Node n9 = new Node(a + a/2., height - 3 * a);
        Node n10 = new Node(2 * a + a/2., height - 3 * a);
        Node n11 = new Node(width - 2 * a - a/2., height - 3 * a);
        Node n12 = new Node(width - a - a/2., height - 3 * a);
        Node n13 = new Node(2 * a, height - 6 * a);
        Node n14 = new Node(2 * a + 2 * a/3., height - 6 * a);
        Node n15 = new Node(2 * a + 2 * a/3. + 2 * a/3., height - 6 * a);
        Node n16 = new Node(2 * a + 2 * a/3. + 2 * a/3. + 2 * a/3., height - 6 * a);
        Node n17 = new Node(2 * a + a/2., height - 13 * a);
        Node n18 = new Node(2 * a + a/2. + a/3., height - 13 * a);
        Node n19 = new Node(2 * a + a/2. + a/3. + a/3., height - 13 * a);
        Node n20 = new Node(2 * a + a/2. + a, height - 13 * a);
        Node n21 = new Node(2 * a + a/2. - a/3., height - 13 * a - a/3.);
        Node n22 = new Node(2 * a + a/2. + a + a/3., height - 13 * a - a/3.);
        Node n23 = new Node(3 * a, height - 15 * a);
        Node n24 = new Node(3 * a, 0);


        Beam b1 = new Beam(n1, n5, testMaterial);
        Beam b2 = new Beam(n2, n6, testMaterial);
        Beam b3 = new Beam(n3, n7, testMaterial);
        Beam b4 = new Beam(n4, n8, testMaterial);
        Beam b5 = new Beam(n5, n6, testMaterial);
        Beam b6 = new Beam(n6, n7, testMaterial);
        Beam b7 = new Beam(n7, n8, testMaterial);
        Beam b8 = new Beam(n5, n9, testMaterial);
        Beam b9 = new Beam(n6, n10, testMaterial);
        Beam b10 = new Beam(n7, n11, testMaterial);
        Beam b11 = new Beam(n8, n12, testMaterial);
        Beam b12 = new Beam(n9, n10, testMaterial);
        Beam b13 = new Beam(n10, n11, testMaterial);
        Beam b14 = new Beam(n11, n12, testMaterial);
        Beam b15 = new Beam(n9, n13, testMaterial);
        Beam b16 = new Beam(n10, n14, testMaterial);
        Beam b17 = new Beam(n11, n15, testMaterial);
        Beam b18 = new Beam(n12, n16, testMaterial);
        Beam b19 = new Beam(n13, n14, testMaterial);
        Beam b20 = new Beam(n14, n15, testMaterial);
        Beam b21 = new Beam(n15, n16, testMaterial);
        Beam b22 = new Beam(n13, n17, testMaterial);
        Beam b23 = new Beam(n14, n18, testMaterial);
        Beam b24 = new Beam(n15, n19, testMaterial);
        Beam b25 = new Beam(n16, n20, testMaterial);
        Beam b26 = new Beam(n17, n18, testMaterial);
        Beam b27 = new Beam(n18, n19, testMaterial);
        Beam b28 = new Beam(n19, n20, testMaterial);
        Beam b29 = new Beam(n17, n21, testMaterial);
        Beam b30 = new Beam(n20, n22, testMaterial);
        Beam b31 = new Beam(n21, n23, testMaterial);
        Beam b32 = new Beam(n22, n23, testMaterial);
        Beam b33 = new Beam(n23, n24, testMaterial);


        structure.addNodes(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16, n17, n18, n19, n20, n21, n22, n23, n24);
        structure.addBeams(b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33);


        boolean[] con = new boolean[3];
        con[0]=true;
        con[1]=true;
        con[2]=true;


        n1.setConstraint(con);
        n2.setConstraint(con);
        n3.setConstraint(con);
        n4.setConstraint(con);
        enumerateDOFs(structure);
        return structure;
    }
    public static Structure getEmpireState() {


        Structure structure = new Structure();
        Material testMaterial = Material.STEEL;


        Node n1 = new Node(0.000000, 18.000000);
        Node n2 = new Node(1.000000, 18.000000);
        Node n3 = new Node(7.000000, 18.000000);
        Node n4 = new Node(8.000000, 18.000000);
        Node n5 = new Node(0.000000, 17.000000);
        Node n6 = new Node(1.000000, 17.000000);
        Node n7 = new Node(7.000000, 17.000000);
        Node n8 = new Node(8.000000, 17.000000);
        Node n9 = new Node(1.000000, 14.000000);
        Node n10 = new Node(2.000000, 14.000000);
        Node n11 = new Node(6.000000, 14.000000);
        Node n12 = new Node(7.000000, 14.000000);
        Node n13 = new Node(2.000000, 5.000000);
        Node n14 = new Node(3.000000, 5.000000);
        Node n15 = new Node(5.000000, 5.000000);
        Node n16 = new Node(6.000000, 5.000000);
        Node n17 = new Node(3.000000, 3.000000);
        Node n18 = new Node(3.500000, 3.000000);
        Node n19 = new Node(4.500000, 3.000000);
        Node n20 = new Node(5.000000, 3.000000);
        Node n21 = new Node(3.500000, 2.000000);
        Node n22 = new Node(4.000000, 2.000000);
        Node n23 = new Node(4.500000, 2.000000);
        Node n24 = new Node(4.000000, 0.000000);


        Beam b1 = new Beam(n1, n5, testMaterial);
        Beam b2 = new Beam(n2, n6, testMaterial);
        Beam b3 = new Beam(n3, n7, testMaterial);
        Beam b4 = new Beam(n4, n8, testMaterial);
        Beam b5 = new Beam(n5, n6, testMaterial);
        Beam b6 = new Beam(n7, n8, testMaterial);
        Beam b7 = new Beam(n6, n9, testMaterial);
        Beam b8 = new Beam(n7, n12, testMaterial);
        Beam b9 = new Beam(n9, n10, testMaterial);
        Beam b10 = new Beam(n10, n11, testMaterial);
        Beam b11 = new Beam(n11, n12, testMaterial);
        Beam b12 = new Beam(n10, n13, testMaterial);
        Beam b13 = new Beam(n11, n16, testMaterial);
        Beam b14 = new Beam(n13, n14, testMaterial);
        Beam b15 = new Beam(n14, n15, testMaterial);
        Beam b16 = new Beam(n15, n16, testMaterial);
        Beam b17 = new Beam(n14, n17, testMaterial);
        Beam b18 = new Beam(n15, n20, testMaterial);
        Beam b19 = new Beam(n17, n18, testMaterial);
        Beam b20 = new Beam(n18, n19, testMaterial);
        Beam b21 = new Beam(n19, n20, testMaterial);
        Beam b22 = new Beam(n18, n21, testMaterial);
        Beam b23 = new Beam(n19, n23, testMaterial);
        Beam b24 = new Beam(n21, n22, testMaterial);
        Beam b25 = new Beam(n22, n23, testMaterial);
        Beam b26 = new Beam(n22, n24, testMaterial);


        structure.addNodes(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16, n17, n18, n19, n20, n21, n22, n23, n24);
        structure.addBeams(b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26);

        boolean[] con = new boolean[3];
        con[0]=true;
        con[1]=true;
        con[2]=true;

        n1.setConstraint(con);
        n2.setConstraint(con);
        n3.setConstraint(con);
        n4.setConstraint(con);
        enumerateDOFs(structure);
        return structure;
    }
    public static Structure getGoldenGate() {

        Structure structure = new Structure();
        Material testMaterial = Material.STEEL;

        Node n1 = new Node(0.000000, 5.000000);
        Node n2 = new Node(2.000000, 5.000000);
        Node n3 = new Node(4.000000, 5.000000);
        Node n4 = new Node(5.000000, 5.000000);
        Node n5 = new Node(6.000000, 5.000000);
        Node n6 = new Node(7.000000, 5.000000);
        Node n7 = new Node(8.000000, 5.000000);
        Node n8 = new Node(9.000000, 5.000000);
        Node n9 = new Node(10.000000, 5.000000);
        Node n10 = new Node(12.000000, 5.000000);
        Node n11 = new Node(14.000000, 5.000000);
        Node n12 = new Node(15.000000, 5.000000);
        Node n13 = new Node(16.000000, 5.000000);
        Node n14 = new Node(17.000000, 5.000000);
        Node n15 = new Node(18.000000, 5.000000);
        Node n16 = new Node(19.000000, 5.000000);
        Node n17 = new Node(20.000000, 5.000000);
        Node n18 = new Node(22.000000, 5.000000);
        Node n19 = new Node(24.000000, 5.000000);
        Node n20 = new Node(7.000000, 8.000000);
        Node n21 = new Node(17.000000, 8.000000);
        Node n22 = new Node(4.000000, 4.000000);
        Node n23 = new Node(5.000000, 3.000000);
        Node n24 = new Node(6.000000, 2.000000);
        Node n25 = new Node(7.000000, 0.000000);
        Node n26 = new Node(8.000000, 2.000000);
        Node n27 = new Node(9.000000, 3.000000);
        Node n28 = new Node(10.000000, 4.000000);
        Node n29 = new Node(14.000000, 4.000000);
        Node n30 = new Node(15.000000, 3.000000);
        Node n31 = new Node(16.000000, 2.000000);
        Node n32 = new Node(17.000000, 0.000000);
        Node n33 = new Node(18.000000, 2.000000);
        Node n34 = new Node(19.000000, 3.000000);
        Node n35 = new Node(20.000000, 4.000000);


        Beam b1 = new Beam(n1, n2, testMaterial);
        Beam b2 = new Beam(n2, n3, testMaterial);
        Beam b3 = new Beam(n3, n4, testMaterial);
        Beam b4 = new Beam(n4, n5, testMaterial);
        Beam b5 = new Beam(n5, n6, testMaterial);
        Beam b6 = new Beam(n6, n7, testMaterial);
        Beam b7 = new Beam(n7, n8, testMaterial);
        Beam b8 = new Beam(n8, n9, testMaterial);
        Beam b9 = new Beam(n9, n10, testMaterial);
        Beam b10 = new Beam(n10, n11, testMaterial);
        Beam b11 = new Beam(n11, n12, testMaterial);
        Beam b12 = new Beam(n12, n13, testMaterial);
        Beam b13 = new Beam(n13, n14, testMaterial);
        Beam b14 = new Beam(n14, n15, testMaterial);
        Beam b15 = new Beam(n15, n16, testMaterial);
        Beam b16 = new Beam(n16, n17, testMaterial);
        Beam b17 = new Beam(n17, n18, testMaterial);
        Beam b18 = new Beam(n18, n19, testMaterial);
        Beam b19 = new Beam(n20, n6, testMaterial);
        Beam b20 = new Beam(n21, n14, testMaterial);
        Beam b21 = new Beam(n3, n22, testMaterial);
        Beam b22 = new Beam(n4, n23, testMaterial);
        Beam b23 = new Beam(n5, n24, testMaterial);
        Beam b24 = new Beam(n6, n25, testMaterial);
        Beam b25 = new Beam(n7, n26, testMaterial);
        Beam b26 = new Beam(n8, n27, testMaterial);
        Beam b27 = new Beam(n9, n28, testMaterial);
        Beam b28 = new Beam(n11, n29, testMaterial);
        Beam b29 = new Beam(n12, n30, testMaterial);
        Beam b30 = new Beam(n13, n31, testMaterial);
        Beam b31 = new Beam(n14, n32, testMaterial);
        Beam b32 = new Beam(n15, n33, testMaterial);
        Beam b33 = new Beam(n16, n34, testMaterial);
        Beam b34 = new Beam(n17, n35, testMaterial);
        Beam b35 = new Beam(n2, n22, testMaterial);
        Beam b36 = new Beam(n22, n23, testMaterial);
        Beam b37 = new Beam(n23, n24, testMaterial);
        Beam b38 = new Beam(n24, n25, testMaterial);
        Beam b39 = new Beam(n25, n26, testMaterial);
        Beam b40 = new Beam(n26, n27, testMaterial);
        Beam b41 = new Beam(n27, n28, testMaterial);
        Beam b42 = new Beam(n28, n10, testMaterial);
        Beam b43 = new Beam(n10, n29, testMaterial);
        Beam b44 = new Beam(n29, n30, testMaterial);
        Beam b45 = new Beam(n30, n31, testMaterial);
        Beam b46 = new Beam(n31, n32, testMaterial);
        Beam b47 = new Beam(n32, n33, testMaterial);
        Beam b48 = new Beam(n33, n34, testMaterial);
        Beam b49 = new Beam(n34, n35, testMaterial);
        Beam b50 = new Beam(n35, n18, testMaterial);


        structure.addNodes(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16, n17, n18, n19, n20, n21, n22, n23, n24, n25, n26, n27, n28, n29, n30, n31, n32, n33, n34, n35);
        structure.addBeams(b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49, b50);

        boolean[] con = new boolean[3];
        con[0]=true;
        con[1]=true;
        con[2]=true;
        n1.setConstraint(con);
        n19.setConstraint(con);
        n20.setConstraint(con);
        n21.setConstraint(con);
        enumerateDOFs(structure);
        return structure;
    }


    public static Structure getTVtower() {

        Structure structure = new Structure();
        Material testMaterial = Material.STEEL;

        Node n1 = new Node(2.000000, 32.000000);
        Node n2 = new Node(5.000000, 32.000000);
        Node n3 = new Node(0.000000, 14.000000);
        Node n4 = new Node(2.500000, 14.000000);
        Node n5 = new Node(4.500000, 14.000000);
        Node n6 = new Node(7.000000, 14.000000);
        Node n7 = new Node(0.000000, 13.000000);
        Node n8 = new Node(7.000000, 13.000000);
        Node n9 = new Node(0.000000, 12.000000);
        Node n10 = new Node(2.500000, 12.000000);
        Node n11 = new Node(4.500000, 12.000000);
        Node n12 = new Node(7.000000, 12.000000);
        Node n13 = new Node(0.000000, 11.000000);
        Node n14 = new Node(2.500000, 11.000000);
        Node n15 = new Node(4.500000, 11.000000);
        Node n16 = new Node(7.000000, 11.000000);
        Node n17 = new Node(0.000000, 8.000000);
        Node n18 = new Node(3.000000, 8.000000);
        Node n19 = new Node(4.000000, 8.000000);
        Node n20 = new Node(7.000000, 8.000000);
        Node n21 = new Node(2.000000, 7.000000);
        Node n22 = new Node(3.000000, 7.000000);
        Node n23 = new Node(4.000000, 7.000000);
        Node n24 = new Node(5.000000, 7.000000);
        Node n25 = new Node(2.000000, 6.000000);
        Node n26 = new Node(3.000000, 6.000000);
        Node n27 = new Node(4.000000, 6.000000);
        Node n28 = new Node(5.000000, 6.000000);
        Node n29 = new Node(3.500000, 1.000000);


        Beam b1 = new Beam(n1, n2, testMaterial);
        Beam b2 = new Beam(n3, n4, testMaterial);
        Beam b3 = new Beam(n4, n5, testMaterial);
        Beam b4 = new Beam(n5, n6, testMaterial);
        Beam b5 = new Beam(n7, n8, testMaterial);
        Beam b6 = new Beam(n9, n10, testMaterial);
        Beam b7 = new Beam(n10, n11, testMaterial);
        Beam b8 = new Beam(n11, n12, testMaterial);
        Beam b9 = new Beam(n13, n14, testMaterial);
        Beam b10 = new Beam(n14, n15, testMaterial);
        Beam b11 = new Beam(n15, n16, testMaterial);
        Beam b12 = new Beam(n17, n18, testMaterial);
        Beam b13 = new Beam(n18, n19, testMaterial);
        Beam b14 = new Beam(n19, n20, testMaterial);
        Beam b15 = new Beam(n21, n22, testMaterial);
        Beam b16 = new Beam(n22, n23, testMaterial);
        Beam b17 = new Beam(n23, n24, testMaterial);
        Beam b18 = new Beam(n25, n26, testMaterial);
        Beam b19 = new Beam(n26, n27, testMaterial);
        Beam b20 = new Beam(n27, n28, testMaterial);
        Beam b21 = new Beam(n1, n4, testMaterial);
        Beam b22 = new Beam(n2, n5, testMaterial);
        Beam b23 = new Beam(n3, n7, testMaterial);
        Beam b24 = new Beam(n6, n8, testMaterial);
        Beam b25 = new Beam(n7, n9, testMaterial);
        Beam b26 = new Beam(n8, n12, testMaterial);
        Beam b27 = new Beam(n10, n14, testMaterial);
        Beam b28 = new Beam(n11, n15, testMaterial);
        Beam b29 = new Beam(n13, n17, testMaterial);
        Beam b30 = new Beam(n16, n20, testMaterial);
        Beam b31 = new Beam(n18, n22, testMaterial);
        Beam b32 = new Beam(n19, n23, testMaterial);
        Beam b33 = new Beam(n21, n25, testMaterial);
        Beam b34 = new Beam(n22, n26, testMaterial);
        Beam b35 = new Beam(n23, n27, testMaterial);
        Beam b36 = new Beam(n24, n28, testMaterial);
        Beam b37 = new Beam(n26, n29, testMaterial);
        Beam b38 = new Beam(n27, n29, testMaterial);


        structure.addNodes(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16, n17, n18, n19, n20, n21, n22, n23, n24, n25, n26, n27, n28, n29);
        structure.addBeams(b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38);

        boolean[] con = new boolean[3];
        con[0]=true;
        con[1]=true;
        con[2]=true;
        n1.setConstraint(con);
        n2.setConstraint(con);
        enumerateDOFs(structure);
        return structure;
    }

    public static Structure getTaipeh() {

        boolean lumped = true; // Make it false for consistent mass matrices!

        Structure structure = new Structure();
        Material testMaterial = Material.STEEL;

        Node n1 = new Node(0.000000, 49.000000);
        Node n2 = new Node(7.000000, 49.000000);
        Node n3 = new Node(1.500000, 39.000000);
        Node n4 = new Node(5.500000, 39.000000);
        Node n5 = new Node(1.000000, 35.500000);
        Node n6 = new Node(1.500000, 35.500000);
        Node n7 = new Node(5.500000, 35.500000);
        Node n8 = new Node(6.000000, 35.500000);
        Node n9 = new Node(1.000000, 32.000000);
        Node n10 = new Node(1.500000, 32.000000);
        Node n11 = new Node(5.500000, 32.000000);
        Node n12 = new Node(6.000000, 32.000000);
        Node n13 = new Node(1.000000, 28.500000);
        Node n14 = new Node(1.500000, 28.500000);
        Node n15 = new Node(5.500000, 28.500000);
        Node n16 = new Node(6.000000, 28.500000);
        Node n17 = new Node(1.000000, 25.000000);
        Node n18 = new Node(1.500000, 25.000000);
        Node n19 = new Node(5.500000, 25.000000);
        Node n20 = new Node(6.000000, 25.000000);
        Node n21 = new Node(1.000000, 21.500000);
        Node n22 = new Node(1.500000, 21.500000);
        Node n23 = new Node(5.500000, 21.500000);
        Node n24 = new Node(6.000000, 21.500000);
        Node n25 = new Node(1.000000, 18.000000);
        Node n26 = new Node(1.500000, 18.000000);
        Node n27 = new Node(5.500000, 18.000000);
        Node n28 = new Node(6.000000, 18.000000);
        Node n29 = new Node(1.000000, 14.500000);
        Node n30 = new Node(1.500000, 14.500000);
        Node n31 = new Node(5.500000, 14.500000);
        Node n32 = new Node(6.000000, 14.500000);
        Node n33 = new Node(1.000000, 11.000000);
        Node n34 = new Node(3.000000, 11.000000);
        Node n35 = new Node(4.000000, 11.000000);
        Node n36 = new Node(6.000000, 11.000000);
        Node n37 = new Node(3.000000, 6.000000);
        Node n38 = new Node(3.500000, 6.000000);
        Node n39 = new Node(4.000000, 6.000000);
        Node n40 = new Node(3.500000, 0.000000);

        Beam b1 = new Beam(n1, n2, testMaterial);
        Beam b2 = new Beam(n3, n4, testMaterial);
        Beam b3 = new Beam(n5, n6, testMaterial);
        Beam b4 = new Beam(n6, n7, testMaterial);
        Beam b5 = new Beam(n7, n8, testMaterial);
        Beam b6 = new Beam(n9, n10, testMaterial);
        Beam b7 = new Beam(n10, n11, testMaterial);
        Beam b8 = new Beam(n11, n12, testMaterial);
        Beam b9 = new Beam(n13, n14, testMaterial);
        Beam b10 = new Beam(n14, n15, testMaterial);
        Beam b11 = new Beam(n15, n16, testMaterial);
        Beam b12 = new Beam(n17, n18, testMaterial);
        Beam b13 = new Beam(n18, n19, testMaterial);
        Beam b14 = new Beam(n19, n20, testMaterial);
        Beam b15 = new Beam(n21, n22, testMaterial);
        Beam b16 = new Beam(n22, n23, testMaterial);
        Beam b17 = new Beam(n23, n24, testMaterial);
        Beam b18 = new Beam(n25, n26, testMaterial);
        Beam b19 = new Beam(n26, n27, testMaterial);
        Beam b20 = new Beam(n27, n28, testMaterial);
        Beam b21 = new Beam(n29, n30, testMaterial);
        Beam b22 = new Beam(n30, n31, testMaterial);
        Beam b23 = new Beam(n31, n32, testMaterial);
        Beam b24 = new Beam(n33, n34, testMaterial);
        Beam b25 = new Beam(n34, n35, testMaterial);
        Beam b26 = new Beam(n35, n36, testMaterial);
        Beam b27 = new Beam(n37, n38, testMaterial);
        Beam b28 = new Beam(n38, n39, testMaterial);
        Beam b29 = new Beam(n1, n3, testMaterial);
        Beam b30 = new Beam(n2, n4, testMaterial);
        Beam b31 = new Beam(n3, n5, testMaterial);
        Beam b32 = new Beam(n4, n8, testMaterial);
        Beam b33 = new Beam(n6, n9, testMaterial);
        Beam b34 = new Beam(n7, n12, testMaterial);
        Beam b35 = new Beam(n10, n13, testMaterial);
        Beam b36 = new Beam(n11, n16, testMaterial);
        Beam b37 = new Beam(n14, n17, testMaterial);
        Beam b38 = new Beam(n15, n20, testMaterial);
        Beam b39 = new Beam(n18, n21, testMaterial);
        Beam b40 = new Beam(n19, n24, testMaterial);
        Beam b41 = new Beam(n22, n25, testMaterial);
        Beam b42 = new Beam(n23, n28, testMaterial);
        Beam b43 = new Beam(n26, n29, testMaterial);
        Beam b44 = new Beam(n27, n32, testMaterial);
        Beam b45 = new Beam(n30, n33, testMaterial);
        Beam b46 = new Beam(n31, n36, testMaterial);
        Beam b47 = new Beam(n34, n37, testMaterial);
        Beam b48 = new Beam(n35, n39, testMaterial);
        Beam b49 = new Beam(n38, n40, testMaterial);


        structure.addNodes(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16, n17, n18, n19, n20, n21, n22, n23, n24, n25, n26, n27, n28, n29, n30, n31, n32, n33, n34, n35, n36, n37, n38, n39, n40);
        structure.addBeams(b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49);

        boolean[] con = new boolean[3];
        con[0]=true;
        con[1]=true;
        con[2]=true;
        n1.setConstraint(con);
        n2.setConstraint(con);
        enumerateDOFs(structure);
        return structure;
    }

    public static Structure getSimpleEiffelTower() {
        double width = 8;
        double height = 16;

        double half = width * 0.5;
        double quarter = width * 0.25;
        double eighth = width * 0.125;
        double sixteenth = width * 1d/16;

        Structure structure = new Structure();

        Node tri00 = new Node(half, height);
        Node tri01 = new Node(eighth, height);
        Node tri02 = new Node((half + eighth)/2, height/2);
        structure.addBeams(BeamFactory.createTriangleShapedBeam(tri00, tri01, tri02));

        Node tri11 = new Node(width - eighth, height);
        Node tri12 = new Node(width - (half + eighth)/2, height/2);
        structure.addBeams(BeamFactory.createTriangleShapedBeam(tri00, tri11, tri12));

        Node tri22 = new Node(half, height/4);

        structure.addBeams(BeamFactory.createTriangleShapedBeam(tri02, tri12, tri22));

        structure.addNodes(tri00, tri01, tri11, tri12, tri02, tri22);
        enumerateDOFs(structure);
        return structure;
    }

    public static Structure getWeirdBridge() {
        double width = 8;
        double height = 8;

        Structure structure = new Structure();
        Material testMaterial = Material.STEEL;

        Node g1 = new Node(width/4, height);
        Node g2 = new Node(width/2, height);
        Node g3 = new Node(3*width/4, height);
        Node s1 = new Node(0, height/2);
        Node s2 = new Node(width/5, height/2);
        Node s3 = new Node(2*width/5, height/2);
        Node s4 = new Node(3*width/5, height/2);
        Node s5 = new Node(4*width/5, height/2);
        Node s6 = new Node(width, height/2);
        Node t1 = new Node(width/4, 0, true); //hinge
        Node t2 = new Node(width/2, 0, true); //hinge
        Node t3 = new Node(3*width/4, 0, true); //hinge

        Beam c1 = new Beam(g1, t1, testMaterial);
        Beam c2 = new Beam(g2, t2, testMaterial);
        Beam c3 = new Beam(g3, t3, testMaterial);
        Beam sb1 = new Beam(s1, s2, testMaterial);
        Beam sb2 = new Beam(s2, s3, testMaterial);
        Beam sb3 = new Beam(s3, s4, testMaterial);
        Beam sb4 = new Beam(s4, s5, testMaterial);
        Beam sb5 = new Beam(s5, s6, testMaterial);
        Beam h1 = new Beam(t1, s2, testMaterial);
        Beam h2 = new Beam(t1, s3, testMaterial);
        Beam h3 = new Beam(t2, s3, testMaterial);
        Beam h4 = new Beam(t2, s4, testMaterial);
        Beam h5 = new Beam(t3, s4, testMaterial);
        Beam h6 = new Beam(t3, s5, testMaterial);

        structure.addNodes(g1,g2,g3,s1,s2,s3,s4,s5,s6,t1,t2,t3);
        structure.addBeams(c1,c2,c3,sb1,sb2,sb3,sb4,sb5,h1,h2,h3,h4,h5,h6);

        boolean[] con = new boolean[3];
        con[0]=true;
        con[1]=true;
        con[2]=true;

        g1.setConstraint(con);
        g2.setConstraint(con);
        g3.setConstraint(con);

        //TODO: Make s2/s3/s4 hinges between h1 and the group sb1,sb2/between h2 and the group sb2,sb3/between h3 and the group sb3/sb4
        //In the current implementation of hinges, each beam makes up one group
        enumerateDOFs(structure);
        return structure;
    }

    public static Structure getHousingBlock() {
        double width = 10;
        double height = 10;

        boolean lumped = true; // Make it false for consistent mass matrices!

        Structure structure = new Structure();
        structure.setLumped(lumped);
        Material testMaterial = Material.STEEL;
        Node n1 = new Node(0, height);
        Node n2 = new Node(width/4, height);
        Node n3 = new Node(width/2, height);
        Node n4 = new Node(3*width/4, height);
        Node n5 = new Node(width, height);

        Node n6 = new Node(0, 3*height/4);
        Node n7 = new Node(width/4, 3*height/4);
        Node n8 = new Node(width/2, 3*height/4);
        Node n9 = new Node(3*width/4, 3*height/4);
        Node n10 = new Node(width, 3*height/4);
        Node n11 = new Node(0, height/2);
        Node n12 = new Node(width/4, height/2);
        Node n13 = new Node(width/2, height/2);
        Node n14 = new Node(3*width/4, height/2);
        Node n15 = new Node(width, height/2);
        Node n16 = new Node(width/4, height/4);
        Node n17 = new Node(width/2, height/4);
        Node n18 = new Node(3*width/4, height/4);
        Node n19 = new Node(width/2, 0);

        Beam b1 = new Beam(n1, n6, testMaterial);
        Beam b2 = new Beam(n2, n7, testMaterial);
        Beam b3 = new Beam(n3, n8, testMaterial);
        Beam b4 = new Beam(n4, n9, testMaterial);
        Beam b5 = new Beam(n5, n10, testMaterial);
        Beam b6 = new Beam(n6, n7, testMaterial);
        Beam b7 = new Beam(n7, n8, testMaterial);
        Beam b8 = new Beam(n8, n9, testMaterial);
        Beam b9 = new Beam(n9, n10, testMaterial);
        Beam b10 = new Beam(n6, n11, testMaterial);
        Beam b11 = new Beam(n7, n12, testMaterial);
        Beam b12 = new Beam(n8, n13, testMaterial);
        Beam b13 = new Beam(n9, n14, testMaterial);
        Beam b14 = new Beam(n10, n15, testMaterial);
        Beam b15 = new Beam(n11, n16, testMaterial);
        Beam b16 = new Beam(n12, n16, testMaterial);
        Beam b17 = new Beam(n13, n17, testMaterial);
        Beam b18 = new Beam(n14, n18, testMaterial);
        Beam b19 = new Beam(n15, n18, testMaterial);
        Beam b20 = new Beam(n16, n19, testMaterial);
        Beam b21 = new Beam(n17, n19, testMaterial);
        Beam b22 = new Beam(n18, n19, testMaterial);
        Beam b23 = new Beam(n11, n12, testMaterial);
        Beam b24 = new Beam(n12, n13, testMaterial);
        Beam b25 = new Beam(n13, n14, testMaterial);
        Beam b26 = new Beam(n14, n15, testMaterial);
        Beam b27 = new Beam(n16, n17, testMaterial);
        Beam b28 = new Beam(n17, n18, testMaterial);

        structure.addNodes(n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15,n16,n17,n18,n19);
        structure.addBeams(b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15,b16,b17,b18,b19,b20,b21,b22,b23,b24,b25,b26,b27,b28);

        boolean[] con = new boolean[3];
        con[0]=true;
        con[1]=true;
        con[2]=true;

        n1.setConstraint(con);
        n2.setConstraint(con);
        n3.setConstraint(con);
        n4.setConstraint(con);
        n5.setConstraint(con);
        enumerateDOFs(structure);
        return structure;
    }

    public static Structure getSimpleElephant() {

        boolean lumped = true; // Make it false for consistent mass matrices!
        int move = 1;
        Structure structure = new Structure();
        //  structure.setLumped(lumped);

        Material testMaterial = Material.STEEL;

        Node n1 = new Node(1+move, 8);
        Node n2 = new Node(2+move, 8); //left foot
        Node n3 = new Node(4+move, 8);
        Node n4 = new Node(5+move, 8); //right foot

        Node n5 = new Node(1+move, 6);
        Node n6 = new Node(2+move, 6); //left foot/tummy
        Node n7 = new Node(4+move, 6);
        Node n8 = new Node(5+move, 6); //right foot/belly

        Node n9 = new Node(0+move, 4); //posterior
        Node n10 = new Node(1+move, 2);
        Node n11 = new Node(4+move, 2);

        Node n12 = new Node(5+move, 1); //ear
        Node n13 = new Node(7+move, 1.5);
        Node n14 = new Node(6.5+move, 4);
        Node n15 = new Node(5+move, 5);
        Node n16 = new Node(3.5+move, 3);

        Node n17 = new Node(6.9+move, 2); //trunk
        Node n18 = new Node(9+move, 4);
        Node n19 = new Node(10+move, 6);
        Node n20 = new Node(10+move, 8, 10);
        Node n21 = new Node(9.5+move, 8);
        Node n22 = new Node(9.5+move, 6);
        Node n23 = new Node(8.6+move, 4.5);
        Node n24 = new Node(8+move, 4);
        Node n25 = new Node(7+move, 4.5);

        Node n26 = new Node(-1+move, 4); //tail
        Node n27 = new Node(-1+move, 5);
        Node n28 = new Node(-0.5+move, 5);
        Node n29 = new Node(-0.5+move, 4.5);

        Node n30 = new Node(8.3 , 3, true);

        Beam b1 = new Beam(n1, n5, testMaterial);
        Beam b2 = new Beam(n2, n6, testMaterial);
        Beam b3 = new Beam(n3, n7, testMaterial);
        Beam b4 = new Beam(n4, n8, testMaterial);

        Beam b5 = new Beam(n6, n7, testMaterial); //belly

        Beam b6 = new Beam(n5, n9, testMaterial);
        Beam b7 = new Beam(n9, n10, testMaterial);
        Beam b8 = new Beam(n10, n11, testMaterial);

        Beam b9 = new Beam(n11, n12, testMaterial);  //ear
        Beam b10 = new Beam(n12, n13, testMaterial);
        Beam b11 = new Beam(n13, n17, testMaterial);
        Beam b12 = new Beam(n17, n14, testMaterial);
        Beam b13 = new Beam(n14, n15, testMaterial);
        Beam b14 = new Beam(n15, n16, testMaterial);
        Beam b15 = new Beam(n16, n11, testMaterial);

        Beam b16 = new Beam(n17, n18, testMaterial); //trunk
        Beam b17 = new Beam(n18, n19, testMaterial);
        Beam b18 = new Beam(n19, n20, testMaterial);
        Beam b19 = new Beam(n20, n21, testMaterial);
        Beam b20 = new Beam(n21, n22, testMaterial);
        Beam b21 = new Beam(n22, n23, testMaterial);
        Beam b22 = new Beam(n23, n24, testMaterial);
        Beam b23 = new Beam(n24, n25, testMaterial);
        Beam b24 = new Beam(n25, n8, testMaterial);

        Beam b25 = new Beam(n5, n6, testMaterial);
        Beam b26 = new Beam(n7, n8, testMaterial);

        Beam b27 = new Beam(n18, n23, testMaterial);
        Beam b28 = new Beam(n19, n22, testMaterial);

        Beam b29 = new Beam(n14, n25, testMaterial);

        Beam b30 = new Beam(n9, n26, testMaterial);
        Beam b31 = new Beam(n26, n27, testMaterial);
        Beam b32 = new Beam(n27, n28, testMaterial);
        Beam b33 = new Beam(n28, n29, testMaterial);

      /*  Beam b34 = new Beam(n9, n16, testMaterial);
        Beam b35 = new Beam(n14, n25, testMaterial);*/


        structure.addNodes(n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15,n16,n17,n18,n19,n20,n21,n22,n23,n24,n25,n26,n27,n28,n29,n30);
        structure.addBeams(b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15,b16,b17,b18,b19,b20,b21,b22,b23,b24,b25,b26,b27,b28,b29,b29,b30,b31,b32,b33);//,b34,b35);

        boolean[] con = new boolean[3];
        con[0]=true;
        con[1]=true;
        con[2]=true;

        n1.setConstraint(con);
        n2.setConstraint(con);
        n3.setConstraint(con);
        n4.setConstraint(con);
        n30.setConstraint(con);

        enumerateDOFs(structure);
        return structure;


    }


    public static Structure getOneWTC() {

        boolean lumped = true; // Make it false for consistent mass matrices!

        Structure structure = new Structure();
        Material testMaterial = Material.STEEL;

        Node n1 = new Node(0.000000, 32.000000);
        Node n2 = new Node(3.000000, 32.000000);
        Node n3 = new Node(6.000000, 32.000000);
        Node n4 = new Node(0.000000, 28.000000);
        Node n5 = new Node(3.000000, 28.000000);
        Node n6 = new Node(6.000000, 28.000000);
        Node n7 = new Node(1.000000, 8.000000);
        Node n8 = new Node(1.500000, 8.000000);
        Node n9 = new Node(4.500000, 8.000000);
        Node n10 = new Node(5.000000, 8.000000);
        Node n11 = new Node(1.500000, 7.500000);
        Node n12 = new Node(2.500000, 7.500000);
        Node n13 = new Node(3.500000, 7.500000);
        Node n14 = new Node(4.500000, 7.500000);
        Node n15 = new Node(3.000000, 0.000000);


        Beam b1 = new Beam(n1, n2, testMaterial);
        Beam b2 = new Beam(n2, n3, testMaterial);
        Beam b3 = new Beam(n4, n5, testMaterial);
        Beam b4 = new Beam(n5, n6, testMaterial);
        Beam b5 = new Beam(n7, n8, testMaterial);
        Beam b6 = new Beam(n8, n9, testMaterial);
        Beam b7 = new Beam(n9, n10, testMaterial);
        Beam b8 = new Beam(n11, n12, testMaterial);
        Beam b9 = new Beam(n12, n13, testMaterial);
        Beam b10 = new Beam(n13, n14, testMaterial);
        Beam b11 = new Beam(n1, n4, testMaterial);
        Beam b12 = new Beam(n2, n5, testMaterial);
        Beam b13 = new Beam(n3, n6, testMaterial);
        Beam b14 = new Beam(n4, n7, testMaterial);
        Beam b15 = new Beam(n5, n7, testMaterial);
        Beam b16 = new Beam(n5, n10, testMaterial);
        Beam b17 = new Beam(n6, n10, testMaterial);
        Beam b18 = new Beam(n8, n11, testMaterial);
        Beam b19 = new Beam(n9, n14, testMaterial);
        Beam b20 = new Beam(n12, n15, testMaterial);
        Beam b21 = new Beam(n13, n15, testMaterial);


        structure.addNodes(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15);
        structure.addBeams(b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21);

        boolean[] con = new boolean[3];
        con[0]=true;
        con[1]=true;
        con[2]=true;
        n1.setConstraint(con);
        n2.setConstraint(con);
        enumerateDOFs(structure);
        return structure;
    }


    public static Structure getTrumpTower() {
        double width = 8;
        double xOffset = -4;
        double height = 8;
        double height2 = 2; //shouldn't be bigger than 4
        double height3 = 1; //shoudln't be bigger than 4

        boolean lumped = true; // Make it false for consistent mass matrices!

        Structure structure = new Structure();
        Material testMaterial = Material.STEEL;

        //Ground
        Node n1 = new Node(width/3+xOffset, height);
        Node n2 = new Node(4*width/9+xOffset, height);
        Node n3 = new Node(5*width/9+xOffset, height);
        Node n4 = new Node(2*width/3+xOffset, height);
        //Left thing
        Node n5 = new Node(8*width/27+xOffset, height-height2/3);
        Node n6 = new Node(8*width/27+xOffset, height-2*height2/3);
        Node n7 = new Node(10*width/27+xOffset, height-height2);
        Node n8 = new Node(4*width/9+xOffset, height-2*height2/3);
        //Right thing
        Node n9 = new Node(19*width/27+xOffset, height-height2/3);
        Node n10 = new Node(19*width/27+xOffset, height-2*height2/3);
        Node n11 = new Node(17*width/27+xOffset, height-height2);
        Node n12 = new Node(5*width/9+xOffset, height-2*height2/3);
        //Middle thing
        Node n13 = new Node(4*width/9+xOffset, height/2);
        Node n14 = new Node(5*width/9+xOffset, height/2);
        Node n15 = new Node(4*width/9+xOffset, height3);
        Node n16 = new Node(5*width/9+xOffset, height3);
        Node n17 = new Node(11*width/27+xOffset, height3);
        Node n18 = new Node(16*width/27+xOffset, height3);
        Node n19 = new Node(12*width/27+xOffset, height3/3);
        Node n20 = new Node(width/2+xOffset, 0);
        Node n21 = new Node(15*width/27+xOffset, height3/3);
        Node n22 = new Node(4*width/9+xOffset, height3/2+height/4);
        Node n23 = new Node(5*width/9+xOffset, height3/2+height/4);
        Node n24 = new Node(4*width/9+xOffset, 3*height/4-height2/3);
        Node n25 = new Node(5*width/9+xOffset, 3*height/4-height2/3);

        //Left thing
        Beam b1 = new Beam(n1, n5, testMaterial);
        Beam b2 = new Beam(n5, n6, testMaterial);
        Beam b3 = new Beam(n6, n7, testMaterial);
        Beam b4 = new Beam(n7, n8, testMaterial);
        Beam b5 = new Beam(n8, n2, testMaterial);
        //Right thing
        Beam b6 = new Beam(n4, n9, testMaterial);
        Beam b7 = new Beam(n9, n10, testMaterial);
        Beam b8 = new Beam(n10, n11, testMaterial);
        Beam b9 = new Beam(n11, n12, testMaterial);
        Beam b10 = new Beam(n12, n3, testMaterial);
        //Middle thing
        Beam b11 = new Beam(n8, n24, testMaterial);
        Beam b12 = new Beam(n24, n13, testMaterial);
        Beam b13 = new Beam(n12, n25, testMaterial);
        Beam b14 = new Beam(n25, n14, testMaterial);
        Beam b15 = new Beam(n13, n22, testMaterial);
        Beam b16 = new Beam(n22, n15, testMaterial);
        Beam b17 = new Beam(n14, n23, testMaterial);
        Beam b18 = new Beam(n23, n16, testMaterial);
        Beam b19 = new Beam(n15, n17, testMaterial);
        Beam b20 = new Beam(n16, n18, testMaterial);
        Beam b21 = new Beam(n17, n19, testMaterial);
        Beam b22 = new Beam(n18, n21, testMaterial);
        Beam b23 = new Beam(n19, n20, testMaterial);
        Beam b24 = new Beam(n20, n21, testMaterial);

        structure.addNodes(n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15,n16,n17,n18,n19,n20,n21,n22,n23,n24,n25);
        structure.addBeams(b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15,b16,b17,b18,b19,b20,b21,b22,b23,b24);

        boolean[] con = new boolean[3];
        con[0]=true;
        con[1]=true;
        con[2]=true;

        n1.setConstraint(con);
        n2.setConstraint(con);
        n3.setConstraint(con);
        n4.setConstraint(con);

        enumerateDOFs(structure);
        return structure;
    }

    public static Structure getBurjKhalifa() {

        boolean lumped = true; // Make it false for consistent mass matrices!

        Structure structure = new Structure();
        Material testMaterial = Material.STEEL;

        Node n1 = new Node(0.000000, 35.000000);
        Node n2 = new Node(5.000000, 35.000000);
        Node n3 = new Node(0.000000, 32.000000);
        Node n4 = new Node(5.000000, 32.000000);
        Node n5 = new Node(4.500000, 30.000000);
        Node n6 = new Node(5.000000, 30.000000);
        Node n7 = new Node(0.000000, 29.000000);
        Node n8 = new Node(0.500000, 29.000000);
        Node n9 = new Node(0.500000, 27.000000);
        Node n10 = new Node(4.500000, 27.000000);
        Node n11 = new Node(4.000000, 25.000000);
        Node n12 = new Node(4.500000, 25.000000);
        Node n13 = new Node(0.500000, 23.000000);
        Node n14 = new Node(1.000000, 23.000000);
        Node n15 = new Node(1.000000, 21.000000);
        Node n16 = new Node(4.000000, 21.000000);
        Node n17 = new Node(3.500000, 19.000000);
        Node n18 = new Node(4.000000, 19.000000);
        Node n19 = new Node(1.000000, 17.000000);
        Node n20 = new Node(1.500000, 17.000000);
        Node n21 = new Node(1.500000, 15.000000);
        Node n22 = new Node(3.500000, 15.000000);
        Node n23 = new Node(3.000000, 12.000000);
        Node n24 = new Node(3.500000, 12.000000);
        Node n25 = new Node(1.500000, 11.000000);
        Node n26 = new Node(2.000000, 11.000000);
        Node n27 = new Node(2.000000, 6.000000);
        Node n28 = new Node(2.500000, 6.000000);
        Node n29 = new Node(2.500000, 3.000000);
        Node n30 = new Node(3.000000, 3.000000);
        Node n31 = new Node(3.000000, 0.000000);


        Beam b1 = new Beam(n1, n2, testMaterial);
        Beam b2 = new Beam(n3, n4, testMaterial);
        Beam b3 = new Beam(n5, n6, testMaterial);
        Beam b4 = new Beam(n7, n8, testMaterial);
        Beam b5 = new Beam(n9, n10, testMaterial);
        Beam b6 = new Beam(n11, n12, testMaterial);
        Beam b7 = new Beam(n13, n14, testMaterial);
        Beam b8 = new Beam(n15, n16, testMaterial);
        Beam b9 = new Beam(n17, n18, testMaterial);
        Beam b10 = new Beam(n19, n20, testMaterial);
        Beam b11 = new Beam(n21, n22, testMaterial);
        Beam b12 = new Beam(n23, n24, testMaterial);
        Beam b13 = new Beam(n25, n26, testMaterial);
        Beam b14 = new Beam(n27, n28, testMaterial);
        Beam b15 = new Beam(n29, n30, testMaterial);
        Beam b16 = new Beam(n1, n3, testMaterial);
        Beam b17 = new Beam(n2, n4, testMaterial);
        Beam b18 = new Beam(n3, n7, testMaterial);
        Beam b19 = new Beam(n4, n6, testMaterial);
        Beam b20 = new Beam(n5, n10, testMaterial);
        Beam b21 = new Beam(n8, n9, testMaterial);
        Beam b22 = new Beam(n9, n13, testMaterial);
        Beam b23 = new Beam(n10, n12, testMaterial);
        Beam b24 = new Beam(n11, n16, testMaterial);
        Beam b25 = new Beam(n14, n15, testMaterial);
        Beam b26 = new Beam(n15, n19, testMaterial);
        Beam b27 = new Beam(n16, n18, testMaterial);
        Beam b28 = new Beam(n17, n22, testMaterial);
        Beam b29 = new Beam(n20, n21, testMaterial);
        Beam b30 = new Beam(n21, n25, testMaterial);
        Beam b31 = new Beam(n22, n24, testMaterial);
        Beam b32 = new Beam(n23, n30, testMaterial);
        Beam b33 = new Beam(n26, n27, testMaterial);
        Beam b34 = new Beam(n28, n29, testMaterial);
        Beam b35 = new Beam(n30, n31, testMaterial);


        structure.addNodes(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16, n17, n18, n19, n20, n21, n22, n23, n24, n25, n26, n27, n28, n29, n30, n31);
        structure.addBeams(b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35);

        boolean[] con = new boolean[3];
        con[0]=true;
        con[1]=true;
        con[2]=true;
        n1.setConstraint(con);
        n2.setConstraint(con);
        enumerateDOFs(structure);
        return structure;
    }

    public static Structure getStructure(Context context, String structureName) {

        FileInputStream fileInputStream = null;

        try {
            fileInputStream = context.openFileInput(structureName);

            Structure structure = StructureIO.readStructure(fileInputStream);

            List<Node> nodes = structure.getNodes();
            List<Beam> beams = structure.getBeams();

            HashSet<Node> nodeSet = new HashSet<>();

            nodeSet.addAll(nodes);

            for (int i = nodes.size() - 1; i >= 0; i--) {
                if (nodes.get(i).getBeams().isEmpty()) nodes.remove(i);
            }

            for (int i = beams.size() - 1; i >= 0; i--) {
                if (!nodeSet.contains(beams.get(i).getStartNode())
                        || !nodeSet.contains(beams.get(i).getEndNode())) beams.remove(i);
            }

            enumerateDOFs(structure);
            return structure;

        } catch (FileNotFoundException e) {
            //TODO: handle exception in the calling function and make appropriate actions.
            Log.e(StructureFactory.class.toString(), "FileNotFound");
        } catch (IOException e) {
            Log.e(StructureFactory.class.toString(), "IOException");
        }

        return new Structure();
    }




    public static void enumerateDOFs(Structure structure){
        int numberofDOF=0;
        for (int i = 0; i < structure.getNodes().size(); i++) {
            Node node = structure.getNodes().get(i);

            List<Integer>  dofs = new ArrayList<>();

            // dof for x direction
            dofs.add(numberofDOF);
            if (node.getConstraint(0)){
                structure.addSingleConDOF(numberofDOF);
            }
            numberofDOF++;

            // dof for y direction
            dofs.add(numberofDOF);
            if (node.getConstraint(1)){
                structure.addSingleConDOF(numberofDOF);
            }
            numberofDOF++;


            if (node.isHinge()){
                List<Beam> beams = node.getBeams();
                for (int j = 0; j < beams.size(); j++) {
                    Beam beam = beams.get(j);

                    // dof for rotation of this beam
                    dofs.add(numberofDOF);

                    if (node.getConstraint(2)){
                        structure.addSingleConDOF(numberofDOF);
                    }

                    if(beam.getStartNode()==node){
                        beam.setSingleDof(0,dofs.get(0));
                        beam.setSingleDof(1,dofs.get(1));
                        beam.setSingleDof(2,numberofDOF);
                    }
                    else {
                        beam.setSingleDof(3,dofs.get(0));
                        beam.setSingleDof(4,dofs.get(1));
                        beam.setSingleDof(5, numberofDOF);
                    }
                    numberofDOF++;

                }
            }
            // rigid connection
            else {
                List<Beam> beams = node.getBeams();

                // dof for rotation of all beams
                dofs.add(numberofDOF);

                if (node.getConstraint(2)){
                    structure.addSingleConDOF(numberofDOF);
                }

                for (int j = 0; j < beams.size(); j++) {
                    Beam beam = beams.get(j);

                    if(beam.getStartNode()==node){
                        beam.setSingleDof(0,dofs.get(0));
                        beam.setSingleDof(1,dofs.get(1));
                        beam.setSingleDof(2,numberofDOF);
                    }
                    else {
                        beam.setSingleDof(3,dofs.get(0));
                        beam.setSingleDof(4,dofs.get(1));
                        beam.setSingleDof(5, numberofDOF);
                    }

                }
                numberofDOF++;

            }

            // set the dofs at the node
            node.setDOF(dofs);
            structure.setNumberOfDOF(numberofDOF);
        }

    }

}
package de.ferienakademie.smartquake.model;

import android.util.Log;

import org.ejml.data.DenseMatrix64F;

import java.util.List;

import de.ferienakademie.smartquake.BuildConfig;

/**
 * Created by yuriy on 21/09/16.
 */

public class Beam {

    private static Material stdMaterial = Material.STEEL;

    private Node startNode;
    private Node endNode;
    private Material material = stdMaterial;
    private float thickness = 0.1f;
    private double length;
    private double sin_theta;
    private double cos_theta;
    private double theta;

    private double[] displacement;


    /**
     *array of degrees of freedom in format [x1, y1, rotation1, x2, y2, rotation2]
      */
    private int[] dofs;



    private DenseMatrix64F elementStiffnessMatrix;
    private DenseMatrix64F elementMassMatrix;

    private DenseMatrix64F elementStiffnessMatrix_globalized;
    private DenseMatrix64F elementMassMatrix_globalized;

    public Beam(Node startNode, Node endNode, float thickness) {
        this.dofs = new int[6];
        this.startNode = startNode;
        this.endNode = endNode;
        startNode.addBeam(this);
        endNode.addBeam(this);
        this.thickness = thickness;
        material = stdMaterial;
    }

    //Kernel1 constructor
    public Beam(Node startNode, Node endNode, Material material) {

        this(startNode, endNode, 0.1f);
        this.displacement = new double[6];
        this.material = material;
        double x1 = startNode.getInitialX(), y1 = startNode.getInitialY();
        double x2 = endNode.getInitialX(), y2 = endNode.getInitialY();
        length = computeLength();

        theta = Math.atan2(y2 - y1, x2 - x1);
        cos_theta = Math.cos(theta); //rotation of displacement
        sin_theta = Math.sin(theta);


    }


    public void computeAll(boolean lumped) {

        double x1 = startNode.getInitialX(), y1 = startNode.getInitialY();
        double x2 = endNode.getInitialX(), y2 = endNode.getInitialY();
        length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));

        theta = Math.atan2(y2 - y1, x2 - x1);
        cos_theta = Math.cos(theta); //rotation of displacement
        sin_theta = Math.sin(theta);

        computeStiffnessMatrix();
        elementStiffnessMatrix_globalized = GlobalizeElementMatrix(elementStiffnessMatrix);

        if (lumped){
            computelumpedMassMatrix();
            elementMassMatrix_globalized = elementMassMatrix;
        }else {
            computeconsistentMassMatrix();
            elementMassMatrix_globalized = GlobalizeElementMatrix(elementMassMatrix);
        }
    }

    double computeLength() {
        double x1 = startNode.getInitialX();
        double y1 = startNode.getInitialY();
        double x2 = endNode.getInitialX();
        double y2 = endNode.getInitialY();

        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    }

    void computeStiffnessMatrix() {
        double EA = this.material.getAxialStiffnessOfBar();  //Young's modulus * AreaOfCrossSection
        double EI = this.material.getBendingStiffnessOfBeam();  //Young's modulus * Moment of Inertia

        elementStiffnessMatrix = new DenseMatrix64F(6, 6);
        elementStiffnessMatrix.zero();

        elementStiffnessMatrix.set(0, 0, EA / length);
        elementStiffnessMatrix.set(0, 3, -EA / length);
        elementStiffnessMatrix.set(1, 1, 12 * EI / (length * length * length));
        elementStiffnessMatrix.set(1, 2, -6 * EI / (length * length));
        elementStiffnessMatrix.set(1, 4, -12 * EI / (length * length * length));
        elementStiffnessMatrix.set(1, 5, -6 * EI / (length * length));

        elementStiffnessMatrix.set(2, 1, -6 * EI / (length * length));
        elementStiffnessMatrix.set(2, 2, 4 * EI / length);
        elementStiffnessMatrix.set(2, 4, 6 * EI / (length * length));
        elementStiffnessMatrix.set(2, 5, 2 * EI / length);

        elementStiffnessMatrix.set(3, 0, -EA / length);
        elementStiffnessMatrix.set(3, 3, EA / length);

        elementStiffnessMatrix.set(4, 1, -12 * EI / (length * length * length));
        elementStiffnessMatrix.set(4, 2, 6 * EI / (length * length));
        elementStiffnessMatrix.set(4, 4, 12 * EI / (length * length * length));
        elementStiffnessMatrix.set(4, 5, 6 * EI / (length * length));

        elementStiffnessMatrix.set(5, 1, -6 * EI / (length * length));
        elementStiffnessMatrix.set(5, 2, 2 * EI / length);
        elementStiffnessMatrix.set(5, 4, 6 * EI / (length * length));
        elementStiffnessMatrix.set(5, 5, 4 * EI / (length));
    }

    void computelumpedMassMatrix() {

        elementMassMatrix = new DenseMatrix64F(6, 6);
        elementMassMatrix.zero();

        double alpha = this.material.getAlpha();
        double mass_per_length = material.getMassPerLength();

        elementMassMatrix.set(0, 0, (0.5 * mass_per_length * length)+ startNode.getNodeMass());
        elementMassMatrix.set(1, 1, (0.5 * mass_per_length * length)+ startNode.getNodeMass());
        elementMassMatrix.set(2, 2, alpha * mass_per_length * length * length * length);
        elementMassMatrix.set(3, 3, (0.5 * mass_per_length * length)+ endNode.getNodeMass());
        elementMassMatrix.set(4, 4, (0.5 * mass_per_length * length)+ endNode.getNodeMass());
        elementMassMatrix.set(5, 5, alpha * mass_per_length * length * length * length);

    }
    void computeconsistentMassMatrix() {

        elementMassMatrix = new DenseMatrix64F(6, 6);
        elementMassMatrix.zero();

        double massperlength= material.getMassPerLength();

        //consistent element mass matrix

        elementMassMatrix = new DenseMatrix64F(6,6);
        elementMassMatrix.zero();
        //row 1
        elementMassMatrix.set(0,0,140*massperlength* length /420+ startNode.getNodeMass());
        elementMassMatrix.set(0,3,70*massperlength* length /420);
        //row 2
        elementMassMatrix.set(1,1,156*massperlength* length /420+ startNode.getNodeMass());
        elementMassMatrix.set(1,2,-22* length *massperlength* length /420);
        elementMassMatrix.set(1,4,54*massperlength* length /420);
        elementMassMatrix.set(1,5,13* length *massperlength* length /420);
        //row 3
        elementMassMatrix.set(2,1,-22* length *massperlength* length /420);
        elementMassMatrix.set(2,2,4* length * length *massperlength* length /420);
        elementMassMatrix.set(2,4,-13* length *massperlength* length /420);
        elementMassMatrix.set(2,5,-3* length * length *massperlength* length /420);
        //row 4
        elementMassMatrix.set(3,0,70*massperlength* length /420);
        elementMassMatrix.set(3,3,140*massperlength* length /420 + endNode.getNodeMass());
        //row 5
        elementMassMatrix.set(4,1,54*massperlength* length /420);
        elementMassMatrix.set(4,2,-13* length *massperlength* length /420);
        elementMassMatrix.set(4,4,156*massperlength* length /420 + endNode.getNodeMass());
        elementMassMatrix.set(4,5,22* length *massperlength* length /420);
        //row 6
        elementMassMatrix.set(5,1,13* length *massperlength* length /420);
        elementMassMatrix.set(5,2,-3* length * length *massperlength* length /420);
        elementMassMatrix.set(5,4,22* length *massperlength* length /420);
        elementMassMatrix.set(5,5,4* length * length *massperlength* length /420);
    }

    public DenseMatrix64F GlobalizeElementMatrix(DenseMatrix64F elementMatrix) {



        DenseMatrix64F elementMatrix_globalized;
        elementMatrix_globalized = new DenseMatrix64F(6, 6);
        elementMatrix_globalized.zero();
        elementMatrix_globalized.set(0, 0, elementMatrix.get(0, 0) * cos_theta * cos_theta + elementMatrix.get(1, 1) * sin_theta * sin_theta);
        elementMatrix_globalized.set(0, 1, elementMatrix.get(0, 0) * cos_theta * sin_theta - elementMatrix.get(1, 1) * cos_theta * sin_theta);
        elementMatrix_globalized.set(0, 2, elementMatrix.get(1, 2) * -sin_theta);
        elementMatrix_globalized.set(0, 3, elementMatrix.get(0, 3) * cos_theta * cos_theta + elementMatrix.get(1, 4) * sin_theta * sin_theta);
        elementMatrix_globalized.set(0, 4, elementMatrix.get(0, 3) * cos_theta * sin_theta - elementMatrix.get(1, 4) * cos_theta * sin_theta);
        elementMatrix_globalized.set(0, 5, elementMatrix.get(1, 5) * -sin_theta);

        elementMatrix_globalized.set(1, 0, (elementMatrix.get(0, 0)- elementMatrix.get(1, 1) )* cos_theta * sin_theta);
        elementMatrix_globalized.set(1, 1, elementMatrix.get(1, 1) * cos_theta * cos_theta + elementMatrix.get(0, 0) * sin_theta * sin_theta);
        elementMatrix_globalized.set(1, 2, elementMatrix.get(1, 2) * cos_theta);
        elementMatrix_globalized.set(1, 3, (elementMatrix.get(0, 3)- elementMatrix.get(1, 4)) * cos_theta * sin_theta);
        elementMatrix_globalized.set(1, 4, elementMatrix.get(1, 4) * cos_theta * cos_theta + elementMatrix.get(0, 3) * sin_theta * sin_theta);
        elementMatrix_globalized.set(1, 5, elementMatrix.get(1, 5) * cos_theta);

        elementMatrix_globalized.set(2, 0, elementMatrix.get(2, 1) * -sin_theta);
        elementMatrix_globalized.set(2, 1, elementMatrix.get(2, 1) * cos_theta);
        elementMatrix_globalized.set(2, 2, elementMatrix.get(2, 2));
        elementMatrix_globalized.set(2, 3, elementMatrix.get(2, 4) * -sin_theta);
        elementMatrix_globalized.set(2, 4, elementMatrix.get(2, 4) * cos_theta);
        elementMatrix_globalized.set(2, 5, elementMatrix.get(2, 5));

        elementMatrix_globalized.set(3, 0, elementMatrix.get(3, 0) * cos_theta * cos_theta + elementMatrix.get(4, 1) * sin_theta * sin_theta);
        elementMatrix_globalized.set(3, 1, (elementMatrix.get(3, 0)- elementMatrix.get(4, 1) ) * cos_theta * sin_theta);
        elementMatrix_globalized.set(3, 2, elementMatrix.get(4, 2) * -sin_theta);
        elementMatrix_globalized.set(3, 3, elementMatrix.get(3, 3) * cos_theta * cos_theta + elementMatrix.get(4, 4) * sin_theta * sin_theta);
        elementMatrix_globalized.set(3, 4, (elementMatrix.get(3, 3)- elementMatrix.get(4, 4)) * cos_theta * sin_theta);
        elementMatrix_globalized.set(3, 5, elementMatrix.get(4, 5) * -sin_theta);

        elementMatrix_globalized.set(4, 0, (elementMatrix.get(3, 0)- elementMatrix.get(4, 1)) * cos_theta * sin_theta);
        elementMatrix_globalized.set(4, 1, elementMatrix.get(4, 1) * cos_theta * cos_theta + elementMatrix.get(3, 0) * sin_theta * sin_theta);
        elementMatrix_globalized.set(4, 2, elementMatrix.get(4, 2) * cos_theta);
        elementMatrix_globalized.set(4, 3, (elementMatrix.get(3, 3)- elementMatrix.get(4, 4)) * cos_theta * sin_theta);
        elementMatrix_globalized.set(4, 4, elementMatrix.get(4, 4) * cos_theta * cos_theta + elementMatrix.get(3, 3) * sin_theta * sin_theta);
        elementMatrix_globalized.set(4, 5, elementMatrix.get(4, 5) * cos_theta);

        elementMatrix_globalized.set(5, 0, elementMatrix.get(5, 1) * -sin_theta);
        elementMatrix_globalized.set(5, 1, elementMatrix.get(5, 1) * cos_theta);
        elementMatrix_globalized.set(5, 2, elementMatrix.get(5, 2));
        elementMatrix_globalized.set(5, 3, elementMatrix.get(4, 5) * -sin_theta);
        elementMatrix_globalized.set(5, 4, elementMatrix.get(4, 5) * cos_theta);
        elementMatrix_globalized.set(5, 5, elementMatrix.get(5, 5));

        return elementMatrix_globalized;
    }




    public Beam(Node startNode, Node endNode) {
        this(startNode, endNode, 0.1f);
    }




    public Beam(double startX, double startY, double endX, double endY) {
        this(new Node(startX, startY), new Node(endX, endY));
    }




    /**
     * Transform global displacements to local displacements.
     * @return local displacements in form:<br>axialDisplacementStartNode, orthogonalDisplacementStartNode, rotationStartNode,
    axialDisplacementEndNode, orthogonalDisplacementEndNode, rotationEndNode
     */
    public Displacements getLocalDisplacements() {

        double startNodeDisplacementX = startNode.getSingleDisplacement(0);
        double startNodeDisplacementY = startNode.getSingleDisplacement(1);
        double endNodeDisplacementX   = endNode.getSingleDisplacement(0);
        double endNodeDisplacementY   = endNode.getSingleDisplacement(1);

        double axialDisplacementStartNode =
                computeLocalAxialDisplacement(startNodeDisplacementX, startNodeDisplacementY);
        double orthogonalDisplacementStartNode =
                computeLocalOrthogonalDisplacement(startNodeDisplacementX, startNodeDisplacementY);
        double axialDisplacementEndNode =
                computeLocalAxialDisplacement(endNodeDisplacementX, endNodeDisplacementY);
        double orthogonalDisplacementEndNode =
                computeLocalOrthogonalDisplacement(endNodeDisplacementX, endNodeDisplacementY);


        if (BuildConfig.DEBUG) { // assert that formulas are right
            double eps = 0.01;
            double v = startNodeDisplacementX * Math.cos(theta) + startNodeDisplacementY * Math.sin(theta);
            if (Math.abs(axialDisplacementStartNode - v) > eps) {
                throw new AssertionError("axialDisplacementStartNode not right: " + axialDisplacementStartNode + " should be " + v);
            }

            double v1 = -startNodeDisplacementX * Math.sin(theta) + startNodeDisplacementY * Math.cos(theta);
            if (Math.abs(orthogonalDisplacementStartNode - v1) > eps) {
                throw new AssertionError("orthogonalStartNode not right: " + orthogonalDisplacementStartNode + " should be " + v1);
            }

            double v2 = endNodeDisplacementX * Math.cos(theta) + endNodeDisplacementY * Math.sin(theta);
            if (Math.abs(axialDisplacementEndNode - v2) > eps) {
                throw new AssertionError("axialDisplacementEndNode not right: " + axialDisplacementEndNode + " should be " + v2);
            }

            double v3 = -endNodeDisplacementX * Math.sin(theta) + endNodeDisplacementY * Math.cos(theta);
            if (Math.abs(orthogonalDisplacementEndNode - v3) > eps) {
                throw new AssertionError("orthogonalDisplacementEndNode wrong: " + orthogonalDisplacementEndNode + " should be " + v3);
            }
        }


        // get correct rotations from the nodes
        double rotationStartNode = startNode.getDisplacementForDof( dofs[2]  );
        double rotationEndNode   = endNode.getDisplacementForDof( dofs[5] );


        return new Displacements(axialDisplacementStartNode, orthogonalDisplacementStartNode, rotationStartNode,
                            axialDisplacementEndNode, orthogonalDisplacementEndNode, rotationEndNode);
    }


    /**
     * U = axial
     * W = orthogonal
     */
    public float[] getGlobalDisplacementAt(double _x) {
        double axialDisplacement = getAxialDisplacement(_x);
        double orthogonalDisplacement = getOrthogonalDisplacement(_x);

        double u = axialDisplacement * Math.cos(theta) - orthogonalDisplacement * Math.sin(theta);
        double w = axialDisplacement * Math.sin(theta) + orthogonalDisplacement * Math.cos(theta);

        return new float[]{(float) u, (float) w};
    }

    private double getOrthogonalDisplacement(double _x) {
        double orthogonalDisplacementStartNode, orthogonalDisplacementEndNode,
                rotationStartNode, rotationEndNode, initialLength;

        Displacements localDisplacements = this.getLocalDisplacements();

        orthogonalDisplacementStartNode = localDisplacements.getOrthogonalDisplacementStartNode();
        orthogonalDisplacementEndNode = localDisplacements.getOrthogonalDisplacementEndNode();
        rotationStartNode = localDisplacements.getRotationStartNode();
        rotationEndNode = localDisplacements.getRotationEndNode();

        initialLength = this.getLength();

        double xl = _x / initialLength;
        double xl2 = xl * xl;
        double xl3 = xl2 * xl;

        double h1 = 1 - 3 * xl2 + 2 * xl3;
        double h2 = (- _x * (xl - 1) * (xl - 1));
        double h3 = 3 * xl2 - 2 * xl3;
        double h4 = ((_x * xl) * (1 - xl));

        return h1 * orthogonalDisplacementStartNode + h2 * rotationStartNode + h3 * orthogonalDisplacementEndNode + h4 * rotationEndNode;
    }

    private double getAxialDisplacement(double _x) {
        Displacements localDisplacements = this.getLocalDisplacements();

        double axialDisplacementStartNode = localDisplacements.getAxialDisplacementStartNode();
        double axialDisplacementEndNode = localDisplacements.getAxialDisplacementEndNode();

        double initialLength = this.getLength();
        double xl = _x / initialLength;

        return xl * axialDisplacementEndNode + (1 - xl) * axialDisplacementStartNode;
    }

    private double computeLocalAxialDisplacement(double x, double y) {
        return x * Math.cos(theta) + y * Math.sin(theta);
    }

    private double computeLocalOrthogonalDisplacement(double x, double y) {
        return -x * Math.sin(theta) + y * Math.cos(theta);
    }

    public int[] getDofs() {
        return dofs;
    }

    public double getLength() {
        return length;
    }

    public Material getMaterial() {
        return material;
    }

    public void setDofs(int[] dofs) {
        this.dofs = dofs;
    }

    public void setSingleDof(int i, int dof){this.dofs[i]=dof; };

    public Node getStartNode() {
        return startNode;
    }

    public void setStartNode(Node startNode) {
        this.startNode = startNode;
    }

    public Node getEndNode() {
        return endNode;
    }

    public void setEndNode(Node endNode) {
        this.endNode = endNode;
    }

    public float getThickness() {
        return thickness;
    }

    public void setThickness(float thickness) {
        this.thickness = thickness;
    }

    @Override
    public boolean equals(Object b) {
        if (b instanceof Beam) {
            Beam temp = (Beam) b;
            return (temp.startNode.equals(startNode) && temp.endNode.equals(endNode))
                    || (temp.endNode.equals(startNode) && temp.startNode.equals(endNode));
        } else {
            return false;
        }
    }

    public DenseMatrix64F getElementStiffnessMatrix() {
        return elementStiffnessMatrix;
    }

    public DenseMatrix64F getElementMassMatrix() {
        return elementMassMatrix;
    }

    public DenseMatrix64F getElementStiffnessMatrix_globalized(){
        return elementStiffnessMatrix_globalized;
    }



    public void setSingleDisplacement(int i,double displacement) {
        this.displacement[i] = displacement;
    }

    public DenseMatrix64F getElementMassMatrix_globalized(){
        return elementMassMatrix_globalized;
    }

    private double normalForce;


    public double calculateNormalForceOfBeam() {
        Displacements localDisplacements = this.getLocalDisplacements();

        double axialDisplacementStartNode = localDisplacements.getAxialDisplacementStartNode();
        double axialDisplacementEndNode = localDisplacements.getAxialDisplacementEndNode();

        double delta_L = axialDisplacementEndNode - axialDisplacementStartNode;
        double EA = material.getAxialStiffnessOfBar();

        normalForce = EA*delta_L/length;
        return normalForce;
    }

    public double getNormalForce() {
        return normalForce;
    }
}
package de.ferienakademie.smartquake.model;

/**
 * Created by alex on 21.09.16.
 */
public class Material {

    public static Material STEEL = new Material(0.01, 0.01, 2.1e11, 7850, 0.005, "rectangular"); //SI-Units - use this (steel) for creating standard  (10cm x 10cm) beam.
    public static Material STEEL2 = new Material(0.02978, 0.02978, 2.1e11, 7850, 0.005, "rectangular"); // for cantilever beam !!! DO NOT CHANGE !!!
    public static Material STEEL3 = new Material(0.2978, 0.2978, 2.1e11, 7850, 0.005, "rectangular"); // for cantilever beam !!! DO NOT CHANGE !!!

    public static Material STEEL_I_SHAPED = new Material(0.001, 0.001, 2.1e11, 7850, 0.005, "I-shaped beam");
    public static Material WOOD = new Material(0.1,0.1,12e9,600,0.005, "rectangular");// Source: Holzbau, wikipedia
    public static Material WOOD_I_SHAPED = new Material(0.1,0.1,12e9,600,0.005, "I-shaped beam");
    public static Material CONCRETE = new Material(0.1,0.1,32e9,2400,0.005, "rectangular");// Source: Betonbau, wikipedia
    public static Material CONCRETE_I_SHAPED = new Material(0.1,0.1,32e9,2400,0.005, "I-shaped beam");
    public static Material BAMBOO = new Material(0.1,0.1,19e9,1000,0.005, "rectangular");

    public String shape;
    //shape = "rectangular" ;  // Can be changed for using other than rectangular cross-sections.

    protected double YoungsModulus = 0;   //Young's modulus
    protected double AreaOfCrossSection = 0;   //cross section
    protected double MomentOfInertia = 0;   //moment of inertia
    protected double AxialStiffnessOfBar = 0;  //
    protected double BendingStiffnessOfBeam = 0;  //rigidity
    protected double HeightOfBeam = 0;   //height of beam (input)
    protected double BreadthOfBeam = 0;   //width of beam (input)
    protected double MassPerLength = 0;

    protected double Density = 0;     //density of material
    protected double alpha = 0;   //alpha for mass matrix
    //may have to change zeroes

    //constructor - The I-shaped beam only uses the 240 profile from DIN 1025; source: https://www.bauforumstahl.de/upload/documents/profile/querschnittswerte/I.pdf
    public Material(double BreadthOfBeam, double HeightOfBeam, double YoungsModulus, double Density, double alpha, String shape){
        this.BreadthOfBeam = BreadthOfBeam;
        this.HeightOfBeam = HeightOfBeam;
        this.YoungsModulus = YoungsModulus;
        this.AreaOfCrossSection = BreadthOfBeam * HeightOfBeam;
        this.MomentOfInertia = BreadthOfBeam * HeightOfBeam * HeightOfBeam * HeightOfBeam /12.;
        this.AxialStiffnessOfBar = YoungsModulus * AreaOfCrossSection;
        this.BendingStiffnessOfBeam = YoungsModulus * MomentOfInertia;
        this.Density = Density;
        this.alpha = alpha;
        this.MassPerLength = Density * AreaOfCrossSection;

        if (shape.equals("I-shaped beam")) { // SI-Units
            this.BreadthOfBeam = 0.106;
            this.HeightOfBeam = 0.24;
            this.AreaOfCrossSection = 46.1 * 0.0001;
            this.MomentOfInertia = 4250 * 0.00000001;
        }

    }

    public void setNewProperties(double b, double h) { //necessary, if BreadthOfBeam and HeightOfBeam are changed - changes all relevant properties - only useful for rectangular cross-sections.
        this.BreadthOfBeam = b;
        this.HeightOfBeam = h;
        AreaOfCrossSection = b*h;
        MomentOfInertia = b*h*h*h/12.;
        AxialStiffnessOfBar = YoungsModulus * AreaOfCrossSection; //update
        BendingStiffnessOfBeam = YoungsModulus * MomentOfInertia; //update
    }

    public void setYoungsModulus(double youngsModulus){
        YoungsModulus = youngsModulus;
        AxialStiffnessOfBar = YoungsModulus * AreaOfCrossSection; //update
        BendingStiffnessOfBeam = YoungsModulus * MomentOfInertia; //update
    }

    public void setDensity(double density){
        this.Density = density;
    }

    public void setAlpha(double alpha){this.alpha = alpha;
    }

    //Most of this is only useful for rectangular cross-sections.

    public double getBreadthOfBeam(){return BreadthOfBeam;}
    public double getHeightOfBeam(){return HeightOfBeam;}
    public double getAreaOfCrossSection(){return AreaOfCrossSection;}
    public double getMassPerLength(){return MassPerLength;}
    public double getMomentOfInertia(){return MomentOfInertia;}
    public double getAxialStiffnessOfBar(){return AxialStiffnessOfBar;}
    public double getBendingStiffnessOfBeam(){return BendingStiffnessOfBeam;}
    public double getDensity(){return Density;}
    public double getAlpha(){return alpha;}

    /*
    public Material(String test){
        if (test.contentEquals("testmat")) {
            this.AreaOfCrossSection = 10;
            this.YoungsModulus = 10e7;
            this.MomentOfInertia = 10;
            this.Density = 7860;
        }
    }
    */  // Not necessary

    //TODO Also include beams with non-quadratic cross sections.

}
package de.ferienakademie.smartquake.model;

import java.util.ArrayList;
import java.util.List;

public class BeamFactory {
    public static List<Beam> createTriangleShapedBeam(Node tri0, Node tri1, Node tri2) {
        List<Beam> beams = new ArrayList<>();
        beams.add(new Beam(tri0, tri1));
        beams.add(new Beam(tri1, tri2));
        beams.add(new Beam(tri2, tri0));

        return beams;
    }
}
package de.ferienakademie.smartquake.model;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import de.ferienakademie.smartquake.managers.PreferenceReader;

/**
 * Created by yuriy on 21/09/16.
 */
public class Node {

    //Initial node position
    private double initialX;
    private double initialY;

    private boolean[] constraint = new boolean[3];

    private List<Integer> DOF; //Degrees of freedom
    private List<Double> displacements; //List of all displacements at the node

    private List <List <Double>>  historyOfDisplacements;
    private List <double[]> historyOfGroundDisplacement;

    private final static double MASSLESS_RADIUS = 0.05;

    private boolean hinge = false;
    private double nodeMass = 0;

    private List<Beam> beams = new ArrayList<>();

    public Node(double x, double y) {
        this.initialX = x;
        this.initialY = y;
        displacements = new ArrayList<>();
        displacements.add(0.0);
        displacements.add(0.0);
        historyOfDisplacements = new ArrayList<>();
        historyOfGroundDisplacement = new ArrayList<>();
    }

    public Node(double x, double y, boolean hinged) {
        this(x, y);
        this.hinge = hinged;
    }

    public Node(double x, double y, double nodeMass) {
        this(x, y);
        this.nodeMass = nodeMass;
    }

    public Node(double x, double y, boolean hinged, double nodeMass) {
        this(x, y, hinged);
        this.nodeMass = nodeMass;
    }


    public Node(double x, double y, List<Integer> DOF) {
        this(x, y);
        this.DOF = DOF;
    }

    public double getInitialX() {
        return initialX;
    }

    public void setInitialX(double initialX) {
        this.initialX = initialX;
    }

    public double getInitialY() {
        return initialY;
    }

    public void setInitialY(double initialY) {
        this.initialY = initialY;
    }

    public void setSingleDisplacement(int i, double value) {
        this.displacements.set(i,value );
    }

    public boolean[] getConstraints() {
        return constraint;
    }


    public double getSingleDisplacement(int i) {
        return this.displacements.get(i);
    }

    public double getDisplacementForDof(int i) {
        return this.displacements.get( DOF.indexOf(i) );
    }

    public void addBeam(Beam beam) {
        beams.add(beam);
    }

    public List<Integer> getDOF() {
        return DOF;
    }

    public void setDOF(List<Integer> DOF) {
        this.DOF = DOF;
        for (int i=0; i<DOF.size(); i++)
            displacements.add(0.0);
    }

    public double getCurrentX() {
        return initialX + displacements.get(0);
    }

    public float getCurrentXf() {
        return (float)(initialX + displacements.get(0));
    }

    public double getCurrentY() {
        return initialY + displacements.get(1);
    }

    public float getCurrentYf() {
        return (float)(initialY + displacements.get(1));
    }

    public double getNodeMass() {
        return nodeMass;
    }

    public void setNodeMass(double nodeMass) {
        this.nodeMass = nodeMass;
    }


    public double getRadius() {
        //If you want to know "why this formula?"
        //Well, there's no real reason for this one! Yep.
        //But ok, let's go into detail: normally it is like r ~ A, so we take the sqrt.
        //Then some scaling b/c alone it would be probably too large. Then we simply add a logarithmic factor to reduce scaling even more.
        //And finally, we add the 0.05 which every mass should have.
        //And that's it. If you got questions or do not like this formula, call me.
        return Math.log10(Math.sqrt(nodeMass) * .001 + 1) + 0.05;
    }

    public void clearBeams() {
        beams.clear();
    }

    public List<Beam> getBeams() {
        return beams;
    }

    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof Node)) return false;

        Node node = (Node) obj;

        return node.initialX == initialX && node.initialY == initialY;
    }

    @Override
    public int hashCode() {
        int result;
        long temp;
        temp = Double.doubleToLongBits(getInitialX());
        result = (int) (temp ^ (temp >>> 32));
        temp = Double.doubleToLongBits(getInitialY());
        result = 31 * result + (int) (temp ^ (temp >>> 32));
        result = 31 * result + (displacements != null ? displacements.hashCode() : 0);
        result = 31 * result + (DOF != null ? DOF.hashCode() : 0);
        temp = Double.doubleToLongBits(getRadius());
        result = 31 * result + (int) (temp ^ (temp >>> 32));
        result = 31 * result + Arrays.hashCode(constraint);
        result = 31 * result + (hinge ? 1 : 0);
        result = 31 * result + beams.hashCode();
        return result;
    }

    public boolean isHinge() {
        return hinge;
    }

    public void setHinge(boolean hinge) {
        this.hinge = hinge;
    }

    public boolean getConstraint(int i) {
        return constraint[i];
    }


    public void setConstraint(boolean[] constraint) {
        this.constraint = constraint;
    }


    public void setSingleConstraint(int i, boolean constraint) {
        this.constraint[i] = constraint;
    }


    public void saveTimeStepDisplacement() {
        historyOfDisplacements.add(displacements);
    }


    public void recallDisplacementOfStep(int i) {
        displacements = historyOfDisplacements.get(i);

        // include ground displacements according to settings
        if (PreferenceReader.groundDisplcements()) {
            double[] groundDisplacements = historyOfGroundDisplacement.get(i);
            displacements.set(0, displacements.get(0) + groundDisplacements[0]);
            displacements.set(1, displacements.get(1) + groundDisplacements[1]);
        }
    }


    public int getLengthofHistory() {
        return historyOfDisplacements.size();
    }


    public void saveTimeStepGroundDisplacement(double[] gD) {
        historyOfGroundDisplacement.add(gD);
    }




}

